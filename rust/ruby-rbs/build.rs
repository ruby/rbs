use serde::Deserialize;
use std::{env, error::Error, fs::File, io::Write, path::Path};

#[derive(Debug, Deserialize)]
struct Config {
    nodes: Vec<Node>,
}

#[derive(Debug, Deserialize)]
struct NodeField {
    name: String,
    c_type: String,
}

#[derive(Debug, Deserialize)]
struct Node {
    name: String,
    rust_name: String,
    fields: Option<Vec<NodeField>>,
}

fn main() -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("../../config.yml")
        .canonicalize()?;

    println!("cargo:rerun-if-changed={}", config_path.display());

    let config_file = File::open(&config_path)?;
    let mut config: Config = serde_yaml::from_reader(config_file)?;

    config.nodes.sort_by(|a, b| a.name.cmp(&b.name));
    generate(&config)?;

    Ok(())
}

enum CIdentifier {
    Type,     // foo_bar_t
    Constant, // FOO_BAR
}

fn convert_name(name: &str, identifier: CIdentifier) -> String {
    let type_name = name.replace("::", "_");
    let lowercase = matches!(identifier, CIdentifier::Type);
    let mut out = String::new();
    let mut prev_is_lower = false;

    for ch in type_name.chars() {
        if ch.is_ascii_uppercase() {
            if prev_is_lower {
                out.push('_');
            }
            out.push(if lowercase {
                ch.to_ascii_lowercase()
            } else {
                ch
            });
            prev_is_lower = false;
        } else if ch == '_' {
            out.push(ch);
            prev_is_lower = false;
        } else {
            out.push(if lowercase {
                ch
            } else {
                ch.to_ascii_uppercase()
            });
            prev_is_lower = ch.is_ascii_lowercase() || ch.is_ascii_digit();
        }
    }

    if lowercase {
        out.push_str("_t");
    }
    out
}

fn generate(config: &Config) -> Result<(), Box<dyn Error>> {
    let out_dir = env::var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("bindings.rs");

    let mut file = File::create(&dest_path)?;

    writeln!(file, "// Generated by build.rs from config.yml")?;
    writeln!(file, "// Nodes to generate: {}", config.nodes.len())?;
    writeln!(file)?;

    // TODO: Go through all of the nodes and generate the structs to back them up
    for node in &config.nodes {
        writeln!(file, "#[allow(dead_code)]")?; // TODO: Remove this once all nodes that need parser are implemented
        writeln!(file, "#[derive(Debug)]")?;
        writeln!(file, "pub struct {} {{", node.rust_name)?;
        writeln!(file, "    parser: *mut rbs_parser_t,")?;
        writeln!(
            file,
            "    pointer: *mut {},",
            convert_name(&node.name, CIdentifier::Type)
        )?;
        writeln!(file, "}}\n")?;

        writeln!(file, "impl {} {{", node.rust_name)?;
        if let Some(fields) = &node.fields {
            for field in fields {
                match field.c_type.as_str() {
                    "rbs_string" => {
                        writeln!(file, "    pub fn {}(&self) -> RBSString {{", field.name)?;
                        writeln!(
                            file,
                            "        RBSString::new(unsafe {{ &(*self.pointer).{} }})",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "bool" => {
                        writeln!(file, "    pub fn {}(&self) -> bool {{", field.name)?;
                        writeln!(file, "        unsafe {{ (*self.pointer).{} }}", field.name)?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_ast_comment" => {
                        writeln!(file, "    pub fn {}(&self) -> CommentNode {{", field.name)?;
                        writeln!(
                            file,
                            "        CommentNode {{ parser: self.parser, pointer: unsafe {{ (*self.pointer).{} }} }}",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_ast_symbol" => {
                        writeln!(file, "    pub fn {}(&self) -> RBSSymbol {{", field.name)?;
                        writeln!(
                            file,
                            "        RBSSymbol::new(unsafe {{ (*self.pointer).{} }}, self.parser)",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_location" => {
                        writeln!(file, "    pub fn {}(&self) -> RBSLocation {{", field.name)?;
                        writeln!(
                            file,
                            "        RBSLocation::new(unsafe {{ (*self.pointer).{} }}, self.parser)",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_location_list" => {
                        writeln!(
                            file,
                            "    pub fn {}(&self) -> RBSLocationList {{",
                            field.name
                        )?;
                        writeln!(
                            file,
                            "        RBSLocationList::new(unsafe {{ (*self.pointer).{} }}, self.parser)",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_node" => {
                        let name = if field.name == "type" {
                            "type_"
                        } else {
                            field.name.as_str()
                        };

                        writeln!(file, "    pub fn {}(&self) -> Node {{", name)?;
                        writeln!(
                            file,
                            "        unsafe {{ Node::new(self.parser, (*self.pointer).{}) }}",
                            name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_node_list" => {
                        writeln!(file, "    pub fn {}(&self) -> NodeList {{", field.name)?;
                        writeln!(
                            file,
                            "        NodeList::new(self.parser, unsafe {{ (*self.pointer).{} }})",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_keyword" => {
                        writeln!(file, "    pub fn {}(&self) -> RBSKeyword {{", field.name)?;
                        writeln!(
                            file,
                            "        RBSKeyword::new(self.parser, unsafe {{ (*self.pointer).{} }})",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    _ => eprintln!("Unknown field type: {}", field.c_type),
                }
            }
        }
        writeln!(file, "}}\n")?;
    }

    // Generate the Node enum to wrap all of the structs
    writeln!(file, "#[derive(Debug)]")?;
    writeln!(file, "pub enum Node {{")?;
    for node in &config.nodes {
        let variant_name = node
            .rust_name
            .strip_suffix("Node")
            .unwrap_or(&node.rust_name);

        writeln!(file, "    {}({}),", variant_name, node.rust_name)?;
    }
    writeln!(file, "}}")?;

    writeln!(file, "impl Node {{")?;
    writeln!(file, "    #[allow(clippy::missing_safety_doc)]")?;
    writeln!(
        file,
        "    pub unsafe fn new(parser: *mut rbs_parser_t, node: *mut rbs_node_t) -> Self {{"
    )?;
    writeln!(file, "        match unsafe {{ (*node).type_ }} {{")?;
    for node in &config.nodes {
        let variant_name = node
            .rust_name
            .strip_suffix("Node")
            .unwrap_or(&node.rust_name);

        let enum_name = convert_name(&node.name, CIdentifier::Constant);

        writeln!(
            file,
            "            rbs_node_type::{} => Self::{}({} {{ parser, pointer: node.cast::<{}>() }}),",
            enum_name,
            variant_name,
            node.rust_name,
            convert_name(&node.name, CIdentifier::Type)
        )?;
    }
    writeln!(
        file,
        "            _ => panic!(\"Unknown node type: {{}}\", unsafe {{ (*node).type_ }})"
    )?;
    writeln!(file, "        }}")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;

    Ok(())
}
