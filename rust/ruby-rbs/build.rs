use serde::Deserialize;
use std::{env, error::Error, fs::File, io::Write, path::Path};

#[derive(Debug, Deserialize)]
struct Config {
    nodes: Vec<Node>,
}

#[derive(Debug, Deserialize)]
struct NodeField {
    name: String,
    c_type: String,
}

#[derive(Debug, Deserialize)]
struct Node {
    name: String,
    rust_name: String,
    fields: Option<Vec<NodeField>>,
}

fn main() -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("../../config.yml")
        .canonicalize()?;

    println!("cargo:rerun-if-changed={}", config_path.display());

    let config_file = File::open(&config_path)?;
    let mut config: Config = serde_yaml::from_reader(config_file)?;

    config.nodes.sort_by(|a, b| a.name.cmp(&b.name));
    generate(&config)?;

    Ok(())
}

fn generate(config: &Config) -> Result<(), Box<dyn Error>> {
    let out_dir = env::var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("bindings.rs");

    let mut file = File::create(&dest_path)?;

    writeln!(file, "// Generated by build.rs from config.yml")?;
    writeln!(file, "// Nodes to generate: {}", config.nodes.len())?;
    writeln!(file)?;

    // TODO: Go through all of the nodes and generate the structs to back them up
    for node in &config.nodes {
        writeln!(file, "#[allow(dead_code)]")?; // TODO: Remove this once all nodes that need parser are implemented
        writeln!(file, "pub struct {} {{", node.rust_name)?;
        writeln!(file, "    parser: *mut rbs_parser_t,")?;
        if let Some(fields) = &node.fields {
            for field in fields {
                match field.c_type.as_str() {
                    "rbs_string" => writeln!(file, "    {}: *const rbs_string_t,", field.name)?,
                    "bool" => writeln!(file, "    {}: bool,", field.name)?,
                    "rbs_ast_symbol" => {
                        writeln!(file, "    {}: *const rbs_ast_symbol_t,", field.name)?
                    }
                    _ => eprintln!("Unknown field type: {}", field.c_type),
                }
            }
        }
        writeln!(file, "}}\n")?;

        writeln!(file, "impl {} {{", node.rust_name)?;
        if let Some(fields) = &node.fields {
            for field in fields {
                match field.c_type.as_str() {
                    "rbs_string" => {
                        writeln!(file, "    pub fn {}(&self) -> RBSString {{", field.name)?;
                        writeln!(file, "        RBSString::new(self.{})", field.name)?;
                        writeln!(file, "    }}")?;
                    }
                    "bool" => {
                        writeln!(file, "    pub fn {}(&self) -> bool {{", field.name)?;
                        writeln!(file, "        self.{}", field.name)?;
                        writeln!(file, "    }}")?;
                    }
                    "rbs_ast_symbol" => {
                        writeln!(file, "    pub fn {}(&self) -> RBSSymbol {{", field.name)?;
                        writeln!(
                            file,
                            "        RBSSymbol::new(self.{}, self.parser)",
                            field.name
                        )?;
                        writeln!(file, "    }}")?;
                    }
                    _ => eprintln!("Unknown field type: {}", field.c_type),
                }
            }
        }
        writeln!(file, "}}\n")?;
    }

    // Generate the Node enum to wrap all of the structs
    writeln!(file, "pub enum Node {{")?;
    for node in &config.nodes {
        let variant_name = node
            .rust_name
            .strip_suffix("Node")
            .unwrap_or(&node.rust_name);

        writeln!(file, "    {}({}),", variant_name, node.rust_name)?;
    }
    writeln!(file, "}}")?;

    Ok(())
}
