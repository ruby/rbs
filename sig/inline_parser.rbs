use RBS::AST::Ruby::Members

module RBS
  class InlineParser
    class Result
      attr_reader buffer: Buffer
      attr_reader prism_result: Prism::ParseResult
      attr_reader declarations: Array[AST::Ruby::Declarations::t]
      attr_reader diagnostics: Array[Diagnostics::t]

      def initialize: (Buffer, Prism::ParseResult) -> void
    end

    module Diagnostics
      type t = NonConstantName
             | ToplevelSingletonClass
             | DeclarationInsideSingletonClass
             | NonConstantSuperClass
             | NonSelfSingletonClass
             | InvalidVisibilityCall
             | InvalidMixinCall
             | UnusedAnnotation
             | AnnotationSyntaxError

      class Base
        attr_reader message: String

        attr_reader location: Location

        def initialize: (Location, String) -> void
      end

      # Module/class definition has non-constant name
      class NonConstantName < Base
      end

      # Singleton class definition at the top level
      class ToplevelSingletonClass < Base
      end

      # <<self singleton class definition has module/class declaration
      class DeclarationInsideSingletonClass < Base
      end

      # Class definition has non-constant superclass
      class NonConstantSuperClass < Base
      end

      # Singleton class definition with non-self receiver
      class NonSelfSingletonClass < Base
      end

      # public/private call with invalid syntax
      class InvalidVisibilityCall < Base
      end

      # prepend/include/extend call with invalid syntax
      class InvalidMixinCall < Base
      end

      # `@rbs` inline annotation is not used
      class UnusedAnnotation < Base
      end

      class AnnotationSyntaxError < Base
      end
    end

    # Returns `true` if the source code is enabled for inline-rbs parsing
    #
    # - `# rbs_inline: enabled`
    # - `# rbs_inline: disabled`
    #
    def self.enabled?: (Prism::ParseResult, default: bool) -> bool

    def self.parse: (Buffer, Prism::ParseResult) -> Result

    class Parser < Prism::Visitor
      type decl_context = AST::Ruby::Declarations::ClassDecl
                        | AST::Ruby::Declarations::SingletonClassDecl
                        | AST::Ruby::Declarations::ModuleDecl

      attr_reader result: Result

      attr_reader comments: Inline::CommentAssociation

      def buffer: () -> Buffer

      def diagnostics: () -> Array[Diagnostics::t]

      %a{pure} def current_context: () -> decl_context?

      %a{pure} def current_context!: () -> decl_context

      attr_reader decl_contexts: Array[decl_context]

      def initialize: (Result, Inline::CommentAssociation) -> void

      def parse: () -> void

      def push_decl_context: (decl_context) { () -> void } -> void

      def insert_class_module_decl: (AST::Ruby::Declarations::ClassDecl | AST::Ruby::Declarations::ModuleDecl) -> void

      def visit_class_node: ...

      def visit_singleton_class_node: ...

      def visit_def_node: ...

      def visit_constant_write_node: ...

      def visibility_member?: (Prism::CallNode) -> (Members::PrivateMember | Members::PublicMember | nil)

      def mixin_member?: (Prism::CallNode) -> (Members::IncludeMember | Members::ExtendMember | Members::PrependMember | nil)

      def push_type_params: [T] (Array[AST::TypeParam]) { () -> T } -> T
                          | (Array[AST::TypeParam]) -> void

      def pop_type_params: () -> void

      @type_params_stack: Array[Array[AST::TypeParam]]
      def current_type_params: () -> Array[AST::TypeParam]

      def current_type_param_names: () -> Array[Symbol]

      # Returns true if the receiver is (implicitly/explicitly) a `self` node
      def self_call?: (Prism::CallNode) -> bool

      # Returns true if the node doesn't have argument
      #
      def no_argument?: (Prism::CallNode) -> bool

      # Returns the argument if the call has exactly one argument
      #
      def one_argument?: (Prism::CallNode) -> Prism::Node?

      # Returns `true` if the node is a constant node
      #
      # * If the node is a simple constant read node `Foo`, or
      # * If the node is a constant path node that parent is a constant node
      #
      def constant_node?: (Prism::Node) -> (Prism::ConstantReadNode | Prism::ConstantPathNode | nil)

      def report_annotation_syntax_error: (AST::Ruby::CommentBlock::AnnotationSyntaxError) -> void

      def report_unused_annotation: (AST::Ruby::Annotation::t) -> void
    end
  end
end
