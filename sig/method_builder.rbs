module RBS
  class DefinitionBuilder
    # MethodBuilder calculates the sequence of methods available on given type
    #
    # The sequence are sorted topologically.
    #
    class MethodBuilder
      # Set of methods defined in a type.
      #
      class Methods
        # The type of the receiver of the method
        #
        type instance_type = Types::ClassInstance | Types::ClassSingleton | Types::Interface

        # Definition of a method in the type
        #
        # The Definition object allows invalid method definition so that more than one _original_ definitions may exist.
        #
        class Definition
          # AST members that can be *original* method definition
          type original = AST::Members::MethodDefinition | AST::Members::Alias | AST::Members::AttrAccessor | AST::Members::AttrWriter | AST::Members::AttrReader
                        | AST::Ruby::Members::DefMember | AST::Ruby::Members::DefSingletonMember

          # AST members that can define overloading methods
          type overloading = AST::Members::MethodDefinition | AST::Ruby::Members::DefMember

          type accessibility = RBS::Definition::accessibility

          attr_reader name: Symbol
          attr_reader type: instance_type
          attr_reader originals: Array[original]
          attr_reader overloads: Array[overloading]
          attr_reader accessibilities: Array[accessibility]

          def initialize: (name: Symbol, type: instance_type, originals: Array[original], overloads: Array[AST::Members::MethodDefinition], accessibilities: Array[accessibility]) -> void

          def original: () -> original?

          def accessibility: () -> accessibility

          def self.empty: (name: Symbol, type: instance_type) -> Definition
        end

        attr_reader type: instance_type
        attr_reader methods: Hash[Symbol, Definition]

        def initialize: (type: instance_type) -> void

        def validate!: () -> self

        def each: () { (Definition) -> void } -> void
                | () -> Enumerator[Definition, void]

        class Sorter
          include TSort[Definition]

          attr_reader methods: Hash[Symbol, Definition]

          def initialize: (Hash[Symbol, Definition]) -> void

          def tsort_each_node: { (Definition) -> void } -> void

          def tsort_each_child: (Definition) { (Definition) -> void } -> void
        end
      end

      type member = AST::Members::t | AST::Ruby::Members::t

      type declaration = Environment::ModuleEntry::declaration | Environment::ClassEntry::declaration

      attr_reader env: Environment
      attr_reader instance_methods: Hash[TypeName, Methods]
      attr_reader singleton_methods: Hash[TypeName, Methods]
      attr_reader interface_methods: Hash[TypeName, Methods]

      def initialize: (env: Environment) -> void

      def build_instance: (TypeName) -> Methods

      def build_singleton: (TypeName) -> Methods

      def build_interface: (TypeName) -> Methods

      private def build_alias: (Methods, Methods::instance_type, member: AST::Members::Alias) -> void

      private def build_attribute: (Methods, Methods::instance_type, member: AST::Members::AttrAccessor | AST::Members::AttrReader | AST::Members::AttrWriter, accessibility: Definition::accessibility) -> void

      private def build_method: (Methods, Methods::instance_type, member: AST::Members::MethodDefinition, accessibility: Definition::accessibility) -> void

      private def build_ruby_method: (Methods, Methods::instance_type, member: AST::Ruby::Members::DefMember | AST::Ruby::Members::DefSingletonMember, accessibility: Definition::accessibility) -> void

      # Enumerates members in declaration with current accessibility
      #
      # * Note that this method doesn't yield accessibility specifier members.
      #
      private def each_member_with_accessibility: (
        declaration,
        ?accessibility: Definition::accessibility
      ) { (member, Definition::accessibility, AST::Ruby::Declarations::SingletonClassDecl?) -> void } -> void

      # Returns another MethodBuilder instance with given `env`
      #
      # Method definitions already computed are kept, but ones associated with type names which is included in `except` set are deleted.
      #
      def update: (env: Environment, except: _Each[TypeName]) -> MethodBuilder
    end
  end
end
