# Random provides an interface to Ruby's pseudo-random number generator, or
# PRNG.  The PRNG produces a deterministic sequence of bits which approximate
# true randomness. The sequence may be represented by integers, floats, or
# binary strings.
#
# The generator may be initialized with either a system-generated or
# user-supplied seed value by using Random.srand.
#
# The class method Random.rand provides the base functionality of Kernel.rand
# along with better handling of floating point values. These are both interfaces
# to the Ruby system PRNG.
#
# Random.new will create a new PRNG with a state independent of the Ruby system
# PRNG, allowing multiple generators with different seed values or sequence
# positions to exist simultaneously. Random objects can be marshaled, allowing
# sequences to be saved and resumed.
#
# PRNGs are currently implemented as a modified Mersenne Twister with a period
# of 2**19937-1.  As this algorithm is *not* for cryptographical use, you must
# use SecureRandom for security purpose, instead of this PRNG.
class Random < Object
  # Returns a random binary string. The argument `size` specifies the length of
  # the returned string.
  #
  def self.bytes: (Integer size) -> String

  # Returns an arbitrary seed value. This is used by Random.new when no seed value
  # is specified as an argument.
  #
  #     Random.new_seed  #=> 115032730400174366788466674494640623225
  #
  def self.new_seed: () -> Integer

  def self.rand: () -> Float
               | (Integer max) -> Integer
               | (Float max) -> Float
               | (::Range[Integer] range) -> Integer?
               | (::Range[Float] range) -> Float?

  def self.seed: () -> Integer

  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self.srand: (?Integer number) -> Integer

  # Returns a string, using platform providing features. Returned value is
  # expected to be a cryptographically secure pseudo-random number in binary form.
  # This method raises a RuntimeError if the feature provided by platform failed
  # to prepare the result.
  #
  # In 2017, Linux manpage random(7) writes that "no cryptographic primitive
  # available today can hope to promise more than 256 bits of security".  So it
  # might be questionable to pass size > 32 to this method.
  #
  #     Random.urandom(8)  #=> "\x78\x41\xBA\xAF\x7D\xEA\xD8\xEA"
  #
  def self.urandom: (untyped size) -> String

  public

  # Returns true if the two generators have the same internal state, otherwise
  # false.  Equivalent generators will return the same sequence of pseudo-random
  # numbers.  Two generators will generally have the same state only if they were
  # initialized with the same seed
  #
  #     Random.new == Random.new             # => false
  #     Random.new(1234) == Random.new(1234) # => true
  #
  # and have the same invocation history.
  #
  #     prng1 = Random.new(1234)
  #     prng2 = Random.new(1234)
  #     prng1 == prng2 # => true
  #
  #     prng1.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => false
  #
  #     prng2.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => true
  #
  def ==: (self other) -> bool

  private

  def initialize_copy: (self object) -> self

  def left: () -> Integer

  def marshal_dump: () -> Array[Integer]

  def marshal_load: (Array[Integer]) -> self

  def state: () -> Integer
end
