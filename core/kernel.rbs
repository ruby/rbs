# <!-- rdoc-file=object.c -->
# The Kernel module is included by class Object, so its methods are available in
# every Ruby object.
#
# The Kernel instance methods are documented in class Object while the module
# methods are documented here.  These methods are called without a receiver and
# thus can be called in functional form:
#
#     sprintf "%.1f", 1.234 #=> "1.2"
#
# ## What's Here
#
# Module Kernel provides methods that are useful for:
#
# *   [Converting](rdoc-ref:Kernel@Converting)
# *   [Querying](rdoc-ref:Kernel@Querying)
# *   [Exiting](rdoc-ref:Kernel@Exiting)
# *   [Exceptions](rdoc-ref:Kernel@Exceptions)
# *   [IO](rdoc-ref:Kernel@IO)
# *   [Procs](rdoc-ref:Kernel@Procs)
# *   [Tracing](rdoc-ref:Kernel@Tracing)
# *   [Subprocesses](rdoc-ref:Kernel@Subprocesses)
# *   [Loading](rdoc-ref:Kernel@Loading)
# *   [Yielding](rdoc-ref:Kernel@Yielding)
# *   [Random Values](rdoc-ref:Kernel@Random+Values)
# *   [Other](rdoc-ref:Kernel@Other)
#
#
# ### Converting
#
# *   #Array: Returns an Array based on the given argument.
# *   #Complex: Returns a Complex based on the given arguments.
# *   #Float: Returns a Float based on the given arguments.
# *   #Hash: Returns a Hash based on the given argument.
# *   #Integer: Returns an Integer based on the given arguments.
# *   #Rational: Returns a Rational based on the given arguments.
# *   #String: Returns a String based on the given argument.
#
#
# ### Querying
#
# *   #__callee__: Returns the called name of the current method as a symbol.
# *   #__dir__: Returns the path to the directory from which the current method
#     is called.
# *   #__method__: Returns the name of the current method as a symbol.
# *   #autoload?: Returns the file to be loaded when the given module is
#     referenced.
# *   #binding: Returns a Binding for the context at the point of call.
# *   #block_given?: Returns `true` if a block was passed to the calling method.
# *   #caller: Returns the current execution stack as an array of strings.
# *   #caller_locations: Returns the current execution stack as an array of
#     Thread::Backtrace::Location objects.
# *   #class: Returns the class of `self`.
# *   #frozen?: Returns whether `self` is frozen.
# *   #global_variables: Returns an array of global variables as symbols.
# *   #local_variables: Returns an array of local variables as symbols.
# *   #test: Performs specified tests on the given single file or pair of files.
#
#
# ### Exiting
#
# *   #abort: Exits the current process after printing the given arguments.
# *   #at_exit: Executes the given block when the process exits.
# *   #exit: Exits the current process after calling any registered `at_exit`
#     handlers.
# *   #exit!: Exits the current process without calling any registered `at_exit`
#     handlers.
#
#
# ### Exceptions
#
# *   #catch: Executes the given block, possibly catching a thrown object.
# *   #raise (aliased as #fail): Raises an exception based on the given
#     arguments.
# *   #throw: Returns from the active catch block waiting for the given tag.
#
#
# ### IO
#
# *   ::pp: Prints the given objects in pretty form.
# *   #gets: Returns and assigns to `$_` the next line from the current input.
# *   #open: Creates an IO object connected to the given stream, file, or
#     subprocess.
# *   #p:  Prints the given objects' inspect output to the standard output.
# *   #print: Prints the given objects to standard output without a newline.
# *   #printf: Prints the string resulting from applying the given format string
#     to any additional arguments.
# *   #putc: Equivalent to <tt.$stdout.putc(object)</tt> for the given object.
# *   #puts: Equivalent to `$stdout.puts(*objects)` for the given objects.
# *   #readline: Similar to #gets, but raises an exception at the end of file.
# *   #readlines: Returns an array of the remaining lines from the current
#     input.
# *   #select: Same as IO.select.
#
#
# ### Procs
#
# *   #lambda: Returns a lambda proc for the given block.
# *   #proc: Returns a new Proc; equivalent to Proc.new.
#
#
# ### Tracing
#
# *   #set_trace_func: Sets the given proc as the handler for tracing, or
#     disables tracing if given `nil`.
# *   #trace_var: Starts tracing assignments to the given global variable.
# *   #untrace_var: Disables tracing of assignments to the given global
#     variable.
#
#
# ### Subprocesses
#
# *   [\`command`](rdoc-ref:Kernel#`): Returns the standard output of running
#     `command` in a subshell.
# *   #exec: Replaces current process with a new process.
# *   #fork: Forks the current process into two processes.
# *   #spawn: Executes the given command and returns its pid without waiting for
#     completion.
# *   #system: Executes the given command in a subshell.
#
#
# ### Loading
#
# *   #autoload: Registers the given file to be loaded when the given constant
#     is first referenced.
# *   #load: Loads the given Ruby file.
# *   #require: Loads the given Ruby file unless it has already been loaded.
# *   #require_relative: Loads the Ruby file path relative to the calling file,
#     unless it has already been loaded.
#
#
# ### Yielding
#
# *   #tap: Yields `self` to the given block; returns `self`.
# *   #then (aliased as #yield_self): Yields `self` to the block and returns the
#     result of the block.
#
#
# ### Random Values
#
# *   #rand: Returns a pseudo-random floating point number strictly between 0.0
#     and 1.0.
# *   #srand: Seeds the pseudo-random number generator with the given number.
#
#
# ### Other
#
# *   #eval: Evaluates the given string as Ruby code.
# *   #loop: Repeatedly executes the given block.
# *   #sleep: Suspends the current thread for the given number of seconds.
# *   #sprintf (aliased as #format): Returns the string resulting from applying
#     the given format string to any additional arguments.
# *   #syscall: Runs an operating system call.
# *   #trap: Specifies the handling of system signals.
# *   #warn: Issue a warning based on the given messages and options.
#
%a{annotate:rdoc:source:from=object.c}
module Kernel : BasicObject
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller(start=1, length=nil)  -> array or nil
  #   - caller(range)                -> array or nil
  # -->
  # Returns the current execution stack---an array containing strings in the form
  # `file:line` or `file:line: in `method'`.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  #     def a(skip)
  #       caller(skip)
  #     end
  #     def b(skip)
  #       a(skip)
  #     end
  #     def c(skip)
  #       b(skip)
  #     end
  #     c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
  #     c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
  #     c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
  #     c(3)   #=> ["prog:13:in `<main>'"]
  #     c(4)   #=> []
  #     c(5)   #=> nil
  #
  def self?.caller: () -> Array[String]
                  | (int start, ?int? length) -> Array[String]?
                  | (range[int?] range) -> Array[String]?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller_locations(start=1, length=nil)    -> array or nil
  #   - caller_locations(range)                  -> array or nil
  # -->
  # Returns the current execution stack---an array containing backtrace location
  # objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  def self?.caller_locations: () -> Array[Thread::Backtrace::Location]
                            | (int start, ?int? length) -> Array[Thread::Backtrace::Location]?
                            | (range[int?] range) -> Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=vm_eval.c
  #   - catch([tag]) {|tag| block }  -> obj
  # -->
  # `catch` executes its block. If `throw` is not called, the block executes
  # normally, and `catch` returns the value of the last expression evaluated.
  #
  #     catch(1) { 123 }            # => 123
  #
  # If `throw(tag2, val)` is called, Ruby searches up its stack for a `catch`
  # block whose `tag` has the same `object_id` as *tag2*. When found, the block
  # stops executing and returns *val* (or `nil` if no second argument was given to
  # `throw`).
  #
  #     catch(1) { throw(1, 456) }  # => 456
  #     catch(1) { throw(1) }       # => nil
  #
  # When `tag` is passed as the first argument, `catch` yields it as the parameter
  # of the block.
  #
  #     catch(1) {|x| x + 2 }       # => 3
  #
  # When no `tag` is given, `catch` yields a new unique object (as from
  # `Object.new`) as the block parameter. This object can then be used as the
  # argument to `throw`, and will match the correct `catch` block.
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_B, 123)
  #         puts "This puts is not reached"
  #       end
  #
  #       puts "This puts is displayed"
  #       456
  #     end
  #
  #     # => 456
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_A, 123)
  #         puts "This puts is still not reached"
  #       end
  #
  #       puts "Now this puts is also not reached"
  #       456
  #     end
  #
  #     # => 123
  #
  def self?.catch: [T] (T tag) { (T tag) -> untyped } -> untyped
                 | () { (Object tag) -> untyped } -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - eval(string [, binding [, filename [,lineno]]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*. If *binding* is given, which
  # must be a Binding object, the evaluation is performed in its context. If the
  # optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(str)
  #       return binding
  #     end
  #     str = "hello"
  #     eval "str + ' Fred'"                      #=> "hello Fred"
  #     eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"
  #
  def self?.eval: (string src, ?Binding? scope, ?string filename, ?int lineno) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - block_given?   -> true or false
  # -->
  # Returns `true` if `yield` would execute a block in the current context. The
  # `iterator?` form is mildly deprecated.
  #
  #     def try
  #       if block_given?
  #         yield
  #       else
  #         "no block"
  #       end
  #     end
  #     try                  #=> "no block"
  #     try { "hello" }      #=> "hello"
  #     try do "hello" end   #=> "hello"
  #
  def self?.block_given?: () -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - local_variables    -> array
  # -->
  # Returns the names of the current local variables.
  #
  #     fred = 1
  #     for i in 1..10
  #        # ...
  #     end
  #     local_variables   #=> [:fred, :i]
  #
  def self?.local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self?.srand: (?int number) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Kernel.fork  [{ block }]   -> integer or nil
  #   - Process.fork [{ block }]   -> integer or nil
  # -->
  # Creates a subprocess. If a block is specified, that block is run in the
  # subprocess, and the subprocess terminates with a status of zero. Otherwise,
  # the `fork` call returns twice, once in the parent, returning the process ID of
  # the child, and once in the child, returning *nil*. The child process can exit
  # using Kernel.exit! to avoid running any `at_exit` functions. The parent
  # process should use Process.wait to collect the termination statuses of its
  # children or use Process.detach to register disinterest in their status;
  # otherwise, the operating system may accumulate zombie processes.
  #
  # The thread calling fork is the only thread in the created child process. fork
  # doesn't copy other threads.
  #
  # If fork is not usable, Process.respond_to?(:fork) returns false.
  #
  # Note that fork(2) is not available on some platforms like Windows and NetBSD
  # 4. Therefore you should use spawn() instead of fork().
  #
  def self?.fork: () -> Integer?
                | () { () -> void } -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - Array(object) -> object or new_array
  # -->
  # Returns an array converted from `object`.
  #
  # Tries to convert `object` to an array using `to_ary` first and `to_a` second:
  #
  #     Array([0, 1, 2])        # => [0, 1, 2]
  #     Array({foo: 0, bar: 1}) # => [[:foo, 0], [:bar, 1]]
  #     Array(0..4)             # => [0, 1, 2, 3, 4]
  #
  # Returns `object` in an array, `[object]`, if `object` cannot be converted:
  #
  #     Array(:foo)             # => [:foo]
  #
  def self?.Array: (nil) -> []
                 | [T] (array[T] | _ToA[T] array_like) -> Array[T]
                 | [T] (T ele) -> [T]

  # <!--
  #   rdoc-file=complex.c
  #   - Complex(x[, y], exception: true)  ->  numeric or nil
  # -->
  # Returns x+i*y;
  #
  #     Complex(1, 2)    #=> (1+2i)
  #     Complex('1+2i')  #=> (1+2i)
  #     Complex(nil)     #=> TypeError
  #     Complex(1, nil)  #=> TypeError
  #
  #     Complex(1, nil, exception: false)  #=> nil
  #     Complex('1+2', exception: false)   #=> nil
  #
  # Syntax of string form:
  #
  #     string form = extra spaces , complex , extra spaces ;
  #     complex = real part | [ sign ] , imaginary part
  #             | real part , sign , imaginary part
  #             | rational , "@" , rational ;
  #     real part = rational ;
  #     imaginary part = imaginary unit | unsigned rational , imaginary unit ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     imaginary unit = "i" | "I" | "j" | "J" ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit };
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See String#to_c.
  #
  def self?.Complex: (_ToC complex_like, ?exception: true) -> Complex
                   | (_ToC complex_like, exception: bool) -> Complex?
                   | (Numeric | String real, ?Numeric | String imag, ?exception: true) -> Complex
                   | (Numeric | String real, ?Numeric | String imag, exception: bool) -> Complex?
                   | (untyped, ?untyped, ?exception: bool) -> Complex?

  # <!--
  #   rdoc-file=kernel.rb
  #   - Float(arg, exception: true)    -> float or nil
  # -->
  # Returns *arg* converted to a float. Numeric types are converted directly, and
  # with exception to String and `nil` the rest are converted using *arg*`.to_f`.
  # Converting a String with invalid characters will result in a ArgumentError.
  # Converting `nil` generates a TypeError.  Exceptions can be suppressed by
  # passing `exception: false`.
  #
  #     Float(1)                 #=> 1.0
  #     Float("123.456")         #=> 123.456
  #     Float("123.0_badstring") #=> ArgumentError: invalid value for Float(): "123.0_badstring"
  #     Float(nil)               #=> TypeError: can't convert nil into Float
  #     Float("123.0_badstring", exception: false)  #=> nil
  #
  def self?.Float: (_ToF float_like, ?exception: true) -> Float
                 | (_ToF float_like, exception: bool) -> Float?
                 | (untyped, ?exception: bool) -> Float?

  # <!--
  #   rdoc-file=object.c
  #   - Hash(object) -> object or new_hash
  # -->
  # Returns a hash converted from `object`.
  #
  # *   If `object` is:
  #
  #     *   A hash, returns `object`.
  #     *   An empty array or `nil`, returns an empty hash.
  #
  #
  # *   Otherwise, if `object.to_hash` returns a hash, returns that hash.
  # *   Otherwise, returns TypeError.
  #
  #
  # Examples:
  #
  #     Hash({foo: 0, bar: 1}) # => {:foo=>0, :bar=>1}
  #     Hash(nil)              # => {}
  #     Hash([])               # => {}
  #
  def self?.Hash: [K, V] (nil | []) -> Hash[K, V]
                | [K, V] (hash[K, V] hash_like) -> Hash[K, V]

  # <!--
  #   rdoc-file=object.c
  #   - Integer(object, base = 0, exception: true) -> integer or nil
  # -->
  # Returns an integer converted from `object`.
  #
  # Tries to convert `object` to an integer using `to_int` first and `to_i`
  # second; see below for exceptions.
  #
  # With a non-zero `base`, `object` must be a string or convertible to a string.
  #
  # #### numeric objects
  #
  # With integer argument `object` given, returns `object`:
  #
  #     Integer(1)                # => 1
  #     Integer(-1)               # => -1
  #
  # With floating-point argument `object` given, returns `object` truncated to an
  # intger:
  #
  #     Integer(1.9)              # => 1  # Rounds toward zero.
  #     Integer(-1.9)             # => -1 # Rounds toward zero.
  #
  # #### string objects
  #
  # With string argument `object` and zero `base` given, returns `object`
  # converted to an integer in base 10:
  #
  #     Integer('100')    # => 100
  #     Integer('-100')   # => -100
  #
  # With `base` zero, string `object` may contain leading characters to specify
  # the actual base (radix indicator):
  #
  #     Integer('0100')  # => 64  # Leading '0' specifies base 8.
  #     Integer('0b100') # => 4   # Leading '0b', specifies base 2.
  #     Integer('0x100') # => 256 # Leading '0x' specifies base 16.
  #
  # With a positive `base` (in range 2..36) given, returns `object` converted to
  # an integer in the given base:
  #
  #     Integer('100', 2)   # => 4
  #     Integer('100', 8)   # => 64
  #     Integer('-100', 16) # => -256
  #
  # With a negative `base` (in range -36..-2) given, returns `object` converted to
  # an integer in the radix indicator if exists or `-base`:
  #
  #     Integer('0x100', -2)   # => 256
  #     Integer('100', -2)     # => 4
  #     Integer('0b100', -8)   # => 4
  #     Integer('100', -8)     # => 64
  #     Integer('0o100', -10)  # => 64
  #     Integer('100', -10)    # => 100
  #
  # `base` -1 is equal the -10 case.
  #
  # When converting strings, surrounding whitespace and embedded underscores are
  # allowed and ignored:
  #
  #     Integer(' 100 ')      # => 100
  #     Integer('-1_0_0', 16) # => -256
  #
  # #### other classes
  #
  # Examples with `object` of various other classes:
  #
  #     Integer(Rational(9, 10)) # => 0  # Rounds toward zero.
  #     Integer(Complex(2, 0))   # => 2  # Imaginary part must be zero.
  #     Integer(Time.now)        # => 1650974042
  #
  # #### keywords
  #
  # With optional keyword argument `exception` given as `true` (the default):
  #
  # *   Raises TypeError if `object` does not respond to `to_int` or `to_i`.
  # *   Raises TypeError if `object` is `nil`.
  # *   Raise ArgumentError if `object` is an invalid string.
  #
  #
  # With `exception` given as `false`, an exception of any kind is suppressed and
  # `nil` is returned.
  #
  def self?.Integer: (int | _ToI int_like, ?exception: true) -> Integer
                   | (int | _ToI int_like, exception: bool) -> Integer?
                   | (string str, int base, ?exception: true) -> Integer
                   | (string str, int base, exception: bool) -> Integer?
                   | (untyped, ?untyped, ?exception: bool) -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - Rational(x, y, exception: true)  ->  rational or nil
  #   - Rational(arg, exception: true)   ->  rational or nil
  # -->
  # Returns `x/y` or `arg` as a Rational.
  #
  #     Rational(2, 3)   #=> (2/3)
  #     Rational(5)      #=> (5/1)
  #     Rational(0.5)    #=> (1/2)
  #     Rational(0.3)    #=> (5404319552844595/18014398509481984)
  #
  #     Rational("2/3")  #=> (2/3)
  #     Rational("0.3")  #=> (3/10)
  #
  #     Rational("10 cents")  #=> ArgumentError
  #     Rational(nil)         #=> TypeError
  #     Rational(1, nil)      #=> TypeError
  #
  #     Rational("10 cents", exception: false)  #=> nil
  #
  # Syntax of the string form:
  #
  #     string form = extra spaces , rational , extra spaces ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit } ;
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See also String#to_r.
  #
  def self?.Rational: (int | _ToR rational_like, ?exception: true) -> Rational
                    | (int | _ToR rational_like, exception: bool) -> Rational?
                    | (int | _ToR numer, ?int | _ToR denom, ?exception: true) -> Rational
                    | (int | _ToR numer, ?int | _ToR denom, exception: bool) -> Rational?
                    | [T] (Numeric & _RationalDiv[T] numer, Numeric denom, ?exception: bool) -> T
                    | [T < Numeric] (T value, 1, ?exception: bool) -> T
                    | (untyped, ?untyped, ?exception: bool) -> Rational?

  interface _RationalDiv[T]
    def /: (Numeric) -> T
  end

  # <!--
  #   rdoc-file=object.c
  #   - String(object) -> object or new_string
  # -->
  # Returns a string converted from `object`.
  #
  # Tries to convert `object` to a string using `to_str` first and `to_s` second:
  #
  #     String([0, 1, 2])        # => "[0, 1, 2]"
  #     String(0..5)             # => "0..5"
  #     String({foo: 0, bar: 1}) # => "{:foo=>0, :bar=>1}"
  #
  # Raises `TypeError` if `object` cannot be converted to a string.
  #
  def self?.String: (string | _ToS string_like) -> String

  # <!--
  #   rdoc-file=eval.c
  #   - __callee__         -> symbol
  # -->
  # Returns the called name of the current method as a Symbol. If called outside
  # of a method, it returns `nil`.
  #
  def self?.__callee__: () -> Symbol?

  # <!--
  #   rdoc-file=eval.c
  #   - __dir__         -> string
  # -->
  # Returns the canonicalized absolute path of the directory of the file from
  # which this method is called. It means symlinks in the path is resolved. If
  # `__FILE__` is `nil`, it returns `nil`. The return value equals to
  # `File.dirname(File.realpath(__FILE__))`.
  #
  def self?.__dir__: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - __method__         -> symbol
  # -->
  # Returns the name at the definition of the current method as a Symbol. If
  # called outside of a method, it returns `nil`.
  #
  def self?.__method__: () -> Symbol?

  # <!--
  #   rdoc-file=io.c
  #   - `command` -> string
  # -->
  # Returns the `$stdout` output from running `command` in a subshell; sets global
  # variable `$?` to the process status.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # Examples:
  #
  #     $ `date`                 # => "Wed Apr  9 08:56:30 CDT 2003\n"
  #     $ `echo oops && exit 99` # => "oops\n"
  #     $ $?                     # => #<Process::Status: pid 17088 exit 99>
  #     $ $?.status              # => 99>
  #
  # The built-in syntax `%x{...}` uses this method.
  #
  def self?.`: (string command) -> String

  # <!--
  #   rdoc-file=process.c
  #   - abort
  #   - Kernel::abort([msg])
  #   - Process.abort([msg])
  # -->
  # Terminate execution immediately, effectively by calling `Kernel.exit(false)`.
  # If *msg* is given, it is written to STDERR prior to terminating.
  #
  def self?.abort: (?string msg) -> bot

  # <!--
  #   rdoc-file=eval_jump.c
  #   - at_exit { block } -> proc
  # -->
  # Converts *block* to a `Proc` object (and therefore binds it at the point of
  # call) and registers it for execution when the program exits. If multiple
  # handlers are registered, they are executed in reverse order of registration.
  #
  #     def do_at_exit(str1)
  #       at_exit { print str1 }
  #     end
  #     at_exit { puts "cruel world" }
  #     do_at_exit("goodbye ")
  #     exit
  #
  # *produces:*
  #
  #     goodbye cruel world
  #
  def self?.at_exit: () { () -> void } -> ^() -> void

  # <!--
  #   rdoc-file=load.c
  #   - autoload(const, filename)   -> nil
  # -->
  # Registers _filename_ to be loaded (using Kernel::require)
  #     the first time that _const_ (which may be a String or
  #     a symbol) is accessed.
  #
  #        autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")
  #
  # If *const* is defined as autoload, the file name to be loaded is replaced with
  # *filename*.  If *const* is defined but not as autoload, does nothing.
  #
  def self?.autoload: (interned module_name, path filename) -> nil

  # <!--
  #   rdoc-file=load.c
  #   - autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload`.
  #
  #     autoload(:B, "b")
  #     autoload?(:B)            #=> "b"
  #
  def self?.autoload?: (interned name, ?boolish inherit) -> String?

  # <!--
  #   rdoc-file=proc.c
  #   - binding -> a_binding
  # -->
  # Returns a `Binding` object, describing the variable and method bindings at the
  # point of call. This object can be used when calling `eval` to execute the
  # evaluated command in this environment. See also the description of class
  # `Binding`.
  #
  #     def get_binding(param)
  #       binding
  #     end
  #     b = get_binding("hello")
  #     eval("param", b)   #=> "hello"
  #
  def self?.binding: () -> Binding

  # <!--
  #   rdoc-file=process.c
  #   - exit(status=true)
  #   - Kernel::exit(status=true)
  #   - Process::exit(status=true)
  # -->
  # Initiates the termination of the Ruby script by raising the SystemExit
  # exception. This exception may be caught. The optional parameter is used to
  # return a status code to the invoking environment. `true` and `FALSE` of
  # *status* means success and failure respectively.  The interpretation of other
  # integer values are system dependent.
  #
  #     begin
  #       exit
  #       puts "never get here"
  #     rescue SystemExit
  #       puts "rescued a SystemExit exception"
  #     end
  #     puts "after begin block"
  #
  # *produces:*
  #
  #     rescued a SystemExit exception
  #     after begin block
  #
  # Just prior to termination, Ruby executes any `at_exit` functions (see
  # Kernel::at_exit) and runs any object finalizers (see
  # ObjectSpace::define_finalizer).
  #
  #     at_exit { puts "at_exit function" }
  #     ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })
  #     exit
  #
  # *produces:*
  #
  #     at_exit function
  #     in finalizer
  #
  def self?.exit: (?int | bool status) -> bot

  # <!--
  #   rdoc-file=process.c
  #   - Process.exit!(status=false)
  # -->
  # Exits the process immediately. No exit handlers are run. *status* is returned
  # to the underlying system as the exit status.
  #
  #     Process.exit!(true)
  #
  def self?.exit!: (?int | bool status) -> bot

  # <!-- rdoc-file=eval.c -->
  # With no arguments, raises the exception in `$!` or raises a RuntimeError if
  # `$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
  # the string as a message. Otherwise, the first parameter should be an
  # `Exception` class (or another object that returns an `Exception` object when
  # sent an `exception` message).  The optional second parameter sets the message
  # associated with the exception (accessible via Exception#message), and the
  # third parameter is an array of callback information (accessible via
  # Exception#backtrace). The `cause` of the generated exception (accessible via
  # Exception#cause) is automatically set to the "current" exception (`$!`), if
  # any. An alternative value, either an `Exception` object or `nil`, can be
  # specified via the `:cause` argument.
  #
  # Exceptions are caught by the `rescue` clause of `begin...end` blocks.
  #
  #     raise "Failed to create socket"
  #     raise ArgumentError, "No parameters", caller
  #
  def self?.fail: () -> bot
                | (string message, ?cause: Exception?) -> bot
                | (_Exception exception, ?_ToS? message, ?String | Array[String] | nil backtrace, ?cause: Exception?) -> bot
                | (_Exception exception, ?cause: Exception?, **untyped) -> bot
  # ^ TODO

  # <!--
  #   rdoc-file=eval.c
  #   - raise
  #   - raise(string, cause: $!)
  #   - raise(exception [, string [, array]], cause: $!)
  #   - fail
  #   - fail(string, cause: $!)
  #   - fail(exception [, string [, array]], cause: $!)
  # -->
  # With no arguments, raises the exception in `$!` or raises a RuntimeError if
  # `$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
  # the string as a message. Otherwise, the first parameter should be an
  # `Exception` class (or another object that returns an `Exception` object when
  # sent an `exception` message).  The optional second parameter sets the message
  # associated with the exception (accessible via Exception#message), and the
  # third parameter is an array of callback information (accessible via
  # Exception#backtrace). The `cause` of the generated exception (accessible via
  # Exception#cause) is automatically set to the "current" exception (`$!`), if
  # any. An alternative value, either an `Exception` object or `nil`, can be
  # specified via the `:cause` argument.
  #
  # Exceptions are caught by the `rescue` clause of `begin...end` blocks.
  #
  #     raise "Failed to create socket"
  #     raise ArgumentError, "No parameters", caller
  #
  alias raise fail

  alias self.raise self.fail

  # <!-- rdoc-file=object.c -->
  # Returns the string resulting from formatting `objects` into `format_string`.
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  # Kernel#format is an alias for Kernel#sprintf.
  #
  def self?.format: (string format, *untyped args) -> String

  # <!--
  #   rdoc-file=object.c
  #   - sprintf(format_string *objects)  -> string
  # -->
  # Returns the string resulting from formatting `objects` into `format_string`.
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  # Kernel#format is an alias for Kernel#sprintf.
  #
  alias sprintf format

  alias self.sprintf self.format

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep=$/ [, getline_args])     -> string or nil
  #   - gets(limit [, getline_args])      -> string or nil
  #   - gets(sep, limit [, getline_args]) -> string or nil
  # -->
  # Returns (and assigns to `$_`) the next line from the list of files in `ARGV`
  # (or `$*`), or from standard input if no files are present on the command line.
  # Returns `nil` at end of file. The optional argument specifies the record
  # separator. The separator is included with the contents of each record. A
  # separator of `nil` reads the entire contents, and a zero-length separator
  # reads the input one paragraph at a time, where paragraphs are divided by two
  # consecutive newlines.  If the first argument is an integer, or optional second
  # argument is given, the returning string would not be longer than the given
  # value in bytes.  If multiple filenames are present in `ARGV`, `gets(nil)` will
  # read the contents one file at a time.
  #
  #     ARGV << "testfile"
  #     print while gets
  #
  # *produces:*
  #
  #     This is line one
  #     This is line two
  #     This is line three
  #     And so on...
  #
  # The style of programming using `$_` as an implicit parameter is gradually
  # losing favor in the Ruby community.
  #
  def self?.gets: (?string? sep, ?int? limit, ?chomp: boolish) -> String?
                | (int limit, ?chomp: boolish) -> String? 

  # <!--
  #   rdoc-file=eval.c
  #   - global_variables    -> array
  # -->
  # Returns an array of the names of global variables. This includes special
  # regexp global variables such as `$~` and `$+`, but does not include the
  # numbered regexp global variables (`$1`, `$2`, etc.).
  #
  #     global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]
  #
  def self?.global_variables: () -> Array[Symbol]

  # <!--
  #   rdoc-file=load.c
  #   - load(file, wrap = false)
  # -->
  # Loads and executes the Ruby program in the file *filename*.
  #
  # If the filename is an absolute path (e.g. starts with '/'), the file will be
  # loaded directly using the absolute path.
  #
  # If the filename is an explicit relative path (e.g. starts with './' or '../'),
  # the file will be loaded using the relative path from the current directory.
  #
  # Otherwise, the file will be searched for in the library directories listed in
  # `$LOAD_PATH` (`$:`). If the file is found in a directory, it will attempt to
  # load the file relative to that directory.  If the file is not found in any of
  # the directories in `$LOAD_PATH`, the file will be loaded using the relative
  # path from the current directory.
  #
  # If the file doesn't exist when there is an attempt to load it, a LoadError
  # will be raised.
  #
  # If the optional *wrap* parameter is `true`, the loaded script will be executed
  # under an anonymous module, protecting the calling program's global namespace.
  # If the optional *wrap* parameter is a module, the loaded script will be
  # executed under the given module. In no circumstance will any local variables
  # in the loaded file be propagated to the loading environment.
  #
  def self?.load: (path filename, ?Module | bool wrap) -> true

  # <!--
  #   rdoc-file=vm_eval.c
  #   - loop { block }
  #   - loop            -> an_enumerator
  # -->
  # Repeatedly executes the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     loop do
  #       print "Input: "
  #       line = gets
  #       break if !line or line =~ /^q/i
  #       # ...
  #     end
  #
  # StopIteration raised in the block breaks the loop.  In this case, loop returns
  # the "result" value stored in the exception.
  #
  #     enum = Enumerator.new { |y|
  #       y << "one"
  #       y << "two"
  #       :ok
  #     }
  #
  #     result = loop {
  #       puts enum.next
  #     } #=> :ok
  #
  def self?.loop: () { () -> void } -> bot
                | () -> Enumerator[nil, bot]

  # <!--
  #   rdoc-file=io.c
  #   - open(path, mode = 'r', perm = 0666, **opts)             -> io or nil
  #   - open(path, mode = 'r', perm = 0666, **opts) {|io| ... } -> obj
  # -->
  # Creates an IO object connected to the given stream, file, or subprocess.
  #
  # Required string argument `path` determines which of the following occurs:
  #
  # *   The file at the specified `path` is opened.
  # *   The process forks.
  # *   A subprocess is created.
  #
  #
  # Each of these is detailed below.
  #
  # **File Opened**
  #
  # If `path` does *not* start with a pipe character (`'|'`), a file stream is
  # opened with `File.open(path, mode, perm, **opts)`.
  #
  # With no block given, file stream is returned:
  #
  #     open('t.txt') # => #<File:t.txt>
  #
  # With a block given, calls the block with the open file stream, then closes the
  # stream:
  #
  #     open('t.txt') {|f| p f } # => #<File:t.txt (closed)>
  #
  # Output:
  #
  #     #<File:t.txt>
  #
  # See File.open for details.
  #
  # **Process Forked**
  #
  # If `path` is the 2-character string `'|-'`, the process forks and the child
  # process is connected to the parent.
  #
  # With no block given:
  #
  #     io = open('|-')
  #     if io
  #       $stderr.puts "In parent, child pid is #{io.pid}."
  #     else
  #       $stderr.puts "In child, pid is #{$$}."
  #     end
  #
  # Output:
  #
  #     In parent, child pid is 27903.
  #     In child, pid is 27903.
  #
  # With a block given:
  #
  #     open('|-') do |io|
  #       if io
  #         $stderr.puts "In parent, child pid is #{io.pid}."
  #       else
  #         $stderr.puts "In child, pid is #{$$}."
  #       end
  #     end
  #
  # Output:
  #
  #     In parent, child pid is 28427.
  #     In child, pid is 28427.
  #
  # **Subprocess Created**
  #
  # If `path` is `'|command'` (`'command' != '-'`), a new subprocess runs the
  # command; its open stream is returned. Note that the command may be processed
  # by shell if it contains shell metacharacters.
  #
  # With no block given:
  #
  #     io = open('|echo "Hi!"') # => #<IO:fd 12>
  #     print io.gets
  #     io.close
  #
  # Output:
  #
  #     "Hi!"
  #
  # With a block given, calls the block with the stream, then closes the stream:
  #
  #     open('|echo "Hi!"') do |io|
  #       print io.gets
  #     end
  #
  # Output:
  #
  #     "Hi!"
  #
  def self?.open: (String name, ?String mode, ?Integer perm) -> IO?
                | [T] (String name, ?String mode, ?Integer perm) { (IO) -> T } -> T
  # ^ TODO, there's also `to_open`.

  # <!--
  #   rdoc-file=io.c
  #   - print(*objects) -> nil
  # -->
  # Equivalent to `$stdout.print(*objects)`, this method is the straightforward
  # way to write to `$stdout`.
  #
  # Writes the given objects to `$stdout`; returns `nil`. Appends the output
  # record separator `$OUTPUT_RECORD_SEPARATOR` `$\`), if it is not `nil`.
  #
  # With argument `objects` given, for each object:
  #
  # *   Converts via its method `to_s` if not a string.
  # *   Writes to `stdout`.
  # *   If not the last object, writes the output field separator
  #     `$OUTPUT_FIELD_SEPARATOR` (`$,` if it is not `nil`.
  #
  #
  # With default separators:
  #
  #     objects = [0, 0.0, Rational(0, 1), Complex(0, 0), :zero, 'zero']
  #     $OUTPUT_RECORD_SEPARATOR
  #     $OUTPUT_FIELD_SEPARATOR
  #     print(*objects)
  #
  # Output:
  #
  #     nil
  #     nil
  #     00.00/10+0izerozero
  #
  # With specified separators:
  #
  #     $OUTPUT_RECORD_SEPARATOR = "\n"
  #     $OUTPUT_FIELD_SEPARATOR = ','
  #     print(*objects)
  #
  # Output:
  #
  #     0,0.0,0/1,0+0i,zero,zero
  #
  # With no argument given, writes the content of `$_` (which is usually the most
  # recent user input):
  #
  #     gets  # Sets $_ to the most recent user input.
  #     print # Prints $_.
  #
  def self?.print: (*_ToS args) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - printf(format_string, *objects)               -> nil
  #   - printf(io, format_string, *objects) -> nil
  # -->
  # Equivalent to:
  #
  #     io.write(sprintf(format_string, *objects))
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  # With the single argument `format_string`, formats `objects` into the string,
  # then writes the formatted string to $stdout:
  #
  #     printf('%4.4d %10s %2.2f', 24, 24, 24.0)
  #
  # Output (on $stdout):
  #
  #     0024         24 24.00#
  #
  # With arguments `io` and `format_string`, formats `objects` into the string,
  # then writes the formatted string to `io`:
  #
  #     printf($stderr, '%4.4d %10s %2.2f', 24, 24, 24.0)
  #
  # Output (on $stderr):
  #
  #     0024         24 24.00# => nil
  #
  # With no arguments, does nothing.
  #
  def self?.printf: () -> nil
                  | (String fmt, *untyped args) -> nil
                  | (_Writer io, string fmt, *untyped args) -> nil

  # <!--
  #   rdoc-file=proc.c
  #   - proc   { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new.
  #
  def self?.proc: () { (*untyped, **untyped) -> untyped } -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - lambda { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new, except the resulting Proc objects check the number of
  # parameters passed when called.
  #
  def self?.lambda: () { (*untyped, **untyped) -> untyped } -> Proc

  # <!--
  #   rdoc-file=io.c
  #   - putc(int) -> int
  # -->
  # Equivalent to:
  #
  #     $stdout.putc(int)
  #
  # See IO#putc for important information regarding multi-byte characters.
  #
  def self?.putc: (String chr) -> String
                | [T < _ToInt] (T chr) -> T

  # <!--
  #   rdoc-file=io.c
  #   - puts(*objects)    -> nil
  # -->
  # Equivalent to
  #
  #     $stdout.puts(objects)
  #
  def self?.puts: (*_ToS objects) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - p(object)   -> obj
  #   - p(*objects) -> array of objects
  #   - p           -> nil
  # -->
  # For each object `obj`, executes:
  #
  #     $stdout.write(obj.inspect, "\n")
  #
  # With one object given, returns the object; with multiple objects given,
  # returns an array containing the objects; with no object given, returns `nil`.
  #
  # Examples:
  #
  #     r = Range.new(0, 4)
  #     p r                 # => 0..4
  #     p [r, r, r]         # => [0..4, 0..4, 0..4]
  #     p                   # => nil
  #
  # Output:
  #
  #     0..4
  #     [0..4, 0..4, 0..4]
  #
  def self?.p: () -> nil
             | [T < _Inspect] (T object) -> T
             | (_Inspect object1, _Inspect object2, *_Inspect objects) -> Array[_Inspect]

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pp(*objs)
  # -->
  # prints arguments in pretty form.
  #
  # pp returns argument(s).
  #
  def self?.pp: () -> nil
              | [T] (T arg0) -> T
              | (untyped, untyped, *untyped) -> Array[untyped]
  # ^ TODO

  # <!--
  #   rdoc-file=random.c
  #   - rand(max=0)    -> number
  # -->
  # If called without an argument, or if `max.to_i.abs == 0`, rand returns a
  # pseudo-random floating point number between 0.0 and 1.0, including 0.0 and
  # excluding 1.0.
  #
  #     rand        #=> 0.2725926052826416
  #
  # When `max.abs` is greater than or equal to 1, `rand` returns a pseudo-random
  # integer greater than or equal to 0 and less than `max.to_i.abs`.
  #
  #     rand(100)   #=> 12
  #
  # When `max` is a Range, `rand` returns a random number where
  # `range.member?(number) == true`.
  #
  # Negative or floating point values for `max` are allowed, but may give
  # surprising results.
  #
  #     rand(-100) # => 87
  #     rand(-0.5) # => 0.8130921818028143
  #     rand(1.9)  # equivalent to rand(1), which is always 0
  #
  # Kernel.srand may be used to ensure that sequences of random numbers are
  # reproducible between different runs of a program.
  #
  # See also Random.rand.
  #
  def self?.rand: (?nil | 0) -> Float
  #               | (int max_exclusive) -> Integer # technically returns `0` if given a zero max value.
  #               | [B < (_Sub[B, int], U] (range[B] rng) -> U
  #               | [B < _Sub[B, Float]]
  #               # | [T < _RandFloat1 & _ToF & Numeric] (range[T] rng) -> Float
  #               # | [T < _RandFloat2[U] & Numeric, U] (range[T] rng) -> U
  #               # | [B] (range[_RandInt[B]] range) -> B
  #               # | [F < (Float | (Numeric & _ToF)), U] (range[_RandFloat[F, U]] range) -> Float
  #               # | [T, B < _RandFloat[T]] (range[B] range) -> T
  #               # F < (Float | (Numeric & _ToF)), U, T < _ToF] (range[_RandFloat[F, U]] range) -> Float
  #               # | (::Range[Float] arg0) -> Float

  # interface _RandInt[T]
  #   def -: (instance rhs) -> int
  #   def +: (Integer rhs) -> T
  # end
  # interface _Sub[I, O]
  #   def -: (I input) -> O
  # end
  # interface _Add[I, O]
  #   def +: (I input) -> O
  # end
  # interface _RandFloat1
  #   def -: (instance rhs) -> F
  #   def +: (Float rhs) -> T
  # end
  # interface _RandFloat[T]# < Numeric #F < (Float | (_ToF & !_ToInt), T]
  #   def -: (instance rhs) -> F
  #   def +: (Float rhs) -> T
  # end

  # <!--
  #   rdoc-file=io.c
  #   - readline(sep = $/, chomp: false)   -> string
  #   - readline(limit, chomp: false)      -> string
  #   - readline(sep, limit, chomp: false) -> string
  # -->
  # Equivalent to method Kernel#gets, except that it raises an exception if called
  # at end-of-stream:
  #
  #     $ cat t.txt | ruby -e "p readlines; readline"
  #     ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #     in `readline': end of file reached (EOFError)
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted.
  #
  def self?.readline: (?string? sep, ?int? limit, ?chomp: boolish) -> String
                    | (int limit, ?chomp: boolish) -> String

  # <!--
  #   rdoc-file=io.c
  #   - readlines(sep = $/, chomp: false, **enc_opts)   -> array
  #   - readlines(limit, chomp: false, **enc_opts)       -> array
  #   - readlines(sep, limit, chomp: false, **enc_opts) -> array
  # -->
  # Returns an array containing the lines returned by calling Kernel#gets until
  # the end-of-stream is reached; (see [Line IO](rdoc-ref:IO@Line+IO)).
  #
  # With only string argument `sep` given, returns the remaining lines as
  # determined by line separator `sep`, or `nil` if none; see [Line
  # Separator](rdoc-ref:IO@Line+Separator):
  #
  #     # Default separator.
  #     $ cat t.txt | ruby -e "p readlines"
  #     ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #
  #     # Specified separator.
  #     $ cat t.txt | ruby -e "p readlines 'li'"
  #     ["First li", "ne\nSecond li", "ne\n\nFourth li", "ne\nFifth li", "ne\n"]
  #
  #     # Get-all separator.
  #     $ cat t.txt | ruby -e "p readlines nil"
  #     ["First line\nSecond line\n\nFourth line\nFifth line\n"]
  #
  #     # Get-paragraph separator.
  #     $ cat t.txt | ruby -e "p readlines ''"
  #     ["First line\nSecond line\n\n", "Fourth line\nFifth line\n"]
  #
  # With only integer argument `limit` given, limits the number of bytes in the
  # line; see [Line Limit](rdoc-ref:IO@Line+Limit):
  #
  #     $cat t.txt | ruby -e "p readlines 10"
  #     ["First line", "\n", "Second lin", "e\n", "\n", "Fourth lin", "e\n", "Fifth line", "\n"]
  #
  #     $cat t.txt | ruby -e "p readlines 11"
  #     ["First line\n", "Second line", "\n", "\n", "Fourth line", "\n", "Fifth line\n"]
  #
  #     $cat t.txt | ruby -e "p readlines 12"
  #     ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #
  # With arguments `sep` and `limit` given, combines the two behaviors; see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit).
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted:
  #
  #     $ cat t.txt | ruby -e "p readlines(chomp: true)"
  #     ["First line", "Second line", "", "Fourth line", "Fifth line"]
  #
  # Optional keyword arguments `enc_opts` specify encoding options; see [Encoding
  # options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def self?.readlines: (?string? sep, ?int? limit, ?chomp: boolish, **untyped enc_opts) -> Array[String]
                     | (int limit, ?chomp: boolish, **untyped enc_opts) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/core_ext/kernel_require.rb
  #   - require(path)
  # -->
  # When RubyGems is required, Kernel#require is replaced with our own which is
  # capable of loading gems on demand.
  #
  # When you call `require 'x'`, this is what happens:
  # *   If the file can be loaded from the existing Ruby loadpath, it is.
  # *   Otherwise, installed gems are searched for a file that matches. If it's
  #     found in gem 'y', that gem is activated (added to the loadpath).
  #
  #
  # The normal `require` functionality of returning false if that file has already
  # been loaded is preserved.
  #
  def self?.require: (path path) -> bool

  # <!--
  #   rdoc-file=load.c
  #   - require_relative(file)
  # -->
  # Ruby tries to load the library named *string* relative to the directory
  # containing the requiring file.  If the file does not exist a LoadError is
  # raised. Returns `true` if the file was loaded and `false` if the file was
  # already loaded before.
  #
  def self?.require_relative: (path feature) -> bool

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_ios, write_ios = [], error_ios = [], timeout = nil) -> array or nil
  # -->
  # Invokes system call [select(2)](https://linux.die.net/man/2/select), which
  # monitors multiple file descriptors, waiting until one or more of the file
  # descriptors becomes ready for some class of I/O operation.
  #
  # Not implemented on all platforms.
  #
  # Each of the arguments `read_ios`, `write_ios`, and `error_ios` is an array of
  # IO objects.
  #
  # Argument `timeout` is an integer timeout interval in seconds.
  #
  # The method monitors the IO objects given in all three arrays, waiting for some
  # to be ready; returns a 3-element array whose elements are:
  #
  # *   An array of the objects in `read_ios` that are ready for reading.
  # *   An array of the objects in `write_ios` that are ready for writing.
  # *   An array of the objects in `error_ios` have pending exceptions.
  #
  #
  # If no object becomes ready within the given `timeout`, `nil` is returned.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after non-blocking methods such
  # as #read_nonblock, #write_nonblock, etc.  The methods raise an exception which
  # is extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how
  # the caller should wait with IO.select.  If IO::WaitReadable is raised, the
  # caller should wait for reading.  If IO::WaitWritable is raised, the caller
  # should wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of non-blocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of non-blocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process; see
  # [select(2)](https://linux.die.net/man/2/select)
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # Example:
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # Output:
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self?.select: [T < _ToIO] (
    Array[T]? read,
    ?Array[T]? write,
    ?Array[T]? errors,
    ?_Timeout? timeout
  ) -> [Array[T], Array[T], Array[T]]

  interface _Timeout
    def divmod: (1) -> [int, _TimeoutNSecs] # technically should return `array[int | _TimeoutNSecs]`
  end

  interface _TimeoutNSecs
    def *: (1000000000) -> int
  end

  # <!--
  #   rdoc-file=process.c
  #   - sleep([duration])    -> integer
  # -->
  # Suspends the current thread for *duration* seconds (which may be any number,
  # including a `Float` with fractional seconds). Returns the actual number of
  # seconds slept (rounded), which may be less than that asked for if another
  # thread calls Thread#run. Called without an argument, sleep() will sleep
  # forever.
  #
  #     Time.new    #=> 2008-03-08 19:56:19 +0900
  #     sleep 1.2   #=> 1
  #     Time.new    #=> 2008-03-08 19:56:20 +0900
  #     sleep 1.9   #=> 2
  #     Time.new    #=> 2008-03-08 19:56:22 +0900
  #
  def self?.sleep: (?nil) -> bot
                 | (_Timeout duration) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - syscall(integer_callno, *arguments)   -> integer
  # -->
  # Invokes Posix system call [syscall(2)](https://linux.die.net/man/2/syscall),
  # which calls a specified function.
  #
  # Calls the operating system function identified by `integer_callno`; returns
  # the result of the function or raises SystemCallError if it failed. The effect
  # of the call is platform-dependent. The arguments and returned value are
  # platform-dependent.
  #
  # For each of `arguments`: if it is an integer, it is passed directly; if it is
  # a string, it is interpreted as a binary sequence of bytes. There may be as
  # many as nine such arguments.
  #
  # Arguments `integer_callno` and `argument`, as well as the returned value, are
  # platform-dependent.
  #
  # Note: Method `syscall` is essentially unsafe and unportable. The DL (Fiddle)
  # library is preferred for safer and a bit more portable programming.
  #
  # Not implemented on all platforms.
  #
  def self?.syscall: (
    int callno,
    ?string | int arg1, 
    ?string | int arg2, 
    ?string | int arg3,
    ?string | int arg4, 
    ?string | int arg5, 
    ?string | int arg6, 
    ?string | int arg7, 
    ?string | int arg8
  ) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - test(cmd, file1 [, file2] ) -> obj
  # -->
  # Uses the character `cmd` to perform various tests on `file1` (first table
  # below) or on `file1` and `file2` (second table).
  #
  # File tests on a single file:
  #
  #     Cmd    Returns   Meaning
  #     "A"  | Time    | Last access time for file1
  #     "b"  | boolean | True if file1 is a block device
  #     "c"  | boolean | True if file1 is a character device
  #     "C"  | Time    | Last change time for file1
  #     "d"  | boolean | True if file1 exists and is a directory
  #     "e"  | boolean | True if file1 exists
  #     "f"  | boolean | True if file1 exists and is a regular file
  #     "g"  | boolean | True if file1 has the setgid bit set
  #     "G"  | boolean | True if file1 exists and has a group
  #          |         | ownership equal to the caller's group
  #     "k"  | boolean | True if file1 exists and has the sticky bit set
  #     "l"  | boolean | True if file1 exists and is a symbolic link
  #     "M"  | Time    | Last modification time for file1
  #     "o"  | boolean | True if file1 exists and is owned by
  #          |         | the caller's effective uid
  #     "O"  | boolean | True if file1 exists and is owned by
  #          |         | the caller's real uid
  #     "p"  | boolean | True if file1 exists and is a fifo
  #     "r"  | boolean | True if file1 is readable by the effective
  #          |         | uid/gid of the caller
  #     "R"  | boolean | True if file is readable by the real
  #          |         | uid/gid of the caller
  #     "s"  | int/nil | If file1 has nonzero size, return the size,
  #          |         | otherwise return nil
  #     "S"  | boolean | True if file1 exists and is a socket
  #     "u"  | boolean | True if file1 has the setuid bit set
  #     "w"  | boolean | True if file1 exists and is writable by
  #          |         | the effective uid/gid
  #     "W"  | boolean | True if file1 exists and is writable by
  #          |         | the real uid/gid
  #     "x"  | boolean | True if file1 exists and is executable by
  #          |         | the effective uid/gid
  #     "X"  | boolean | True if file1 exists and is executable by
  #          |         | the real uid/gid
  #     "z"  | boolean | True if file1 exists and has a zero length
  #
  # Tests that take two files:
  #
  #     "-"  | boolean | True if file1 and file2 are identical
  #     "="  | boolean | True if the modification times of file1
  #          |         | and file2 are equal
  #     "<"  | boolean | True if the modification time of file1
  #          |         | is prior to that of file2
  #     ">"  | boolean | True if the modification time of file1
  #          |         | is after that of file2
  #
  def self?.test: (
      'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'G' | 'k' | 'o' | 'O' | 'p' | 'S' | 'u' | 'z' |
       98 |  99 | 100 | 101 | 102 | 103 |  71 | 107 | 111 |  79 | 112 |  83 | 117 | 122,
      io | path file) -> bool
    | ('l' | 'r' | 'R' | 'w' | 'W' | 'x' | 'X' | 108 | 114 | 82 | 119 | 87 | 120 | 88, path filename) -> bool
    | ('s' | 115, io | path filename) -> Integer?
    | ('M' | 'A' | 'C' | 77  | 65 | 67, io | path file) -> Time
    | ('-' | '=' | '<' | '>' | 45 | 60 | 61 | 62, io | path file1, io | path file2) -> bool
    | (String | int cmd, io | path file1, ?io | path file2) -> (bool | Integer? | Time)
  # <!--
  #   rdoc-file=vm_eval.c
  #   - throw(tag [, obj])
  # -->
  # Transfers control to the end of the active `catch` block waiting for *tag*.
  # Raises `UncaughtThrowError` if there is no `catch` block for the *tag*. The
  # optional second parameter supplies a return value for the `catch` block, which
  # otherwise defaults to `nil`. For examples, see Kernel::catch.
  #
  def self?.throw: (untyped tag, ?untyped obj) -> bot

  # <!--
  #   rdoc-file=warning.rb
  #   - warn(*msgs, uplevel: nil, category: nil)   -> nil
  # -->
  # If warnings have been disabled (for example with the `-W0` flag), does
  # nothing.  Otherwise, converts each of the messages to strings, appends a
  # newline character to the string if the string does not end in a newline, and
  # calls Warning.warn with the string.
  #
  #       warn("warning 1", "warning 2")
  #
  #     <em>produces:</em>
  #
  #       warning 1
  #       warning 2
  #
  # If the `uplevel` keyword argument is given, the string will be prepended with
  # information for the given caller frame in the same format used by the
  # `rb_warn` C function.
  #
  #       # In baz.rb
  #       def foo
  #         warn("invalid call to foo", uplevel: 1)
  #       end
  #
  #       def bar
  #         foo
  #       end
  #
  #       bar
  #
  #     <em>produces:</em>
  #
  #       baz.rb:6: warning: invalid call to foo
  #
  # If `category` keyword argument is given, passes the category to
  # `Warning.warn`.  The category given must be be one of the following
  # categories:
  #
  # :deprecated
  # :   Used for warning for deprecated functionality that may be removed in the
  #     future.
  # :experimental
  # :   Used for experimental features that may change in future releases.
  #
  def self?.warn: (*_ToS msg, ?uplevel: int?, ?category: Warning::category?) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - exec([env,] command... [,options])
  # -->
  # Replaces the current process by running the given external *command*, which
  # can take one of the following forms:
  #
  # `exec(commandline)`
  # :   command line string which is passed to the standard shell
  # `exec(cmdname, arg1, ...)`
  # :   command name and one or more arguments (no shell)
  # `exec([cmdname, argv0], arg1, ...)`
  # :   command name, `argv[0]` and zero or more arguments (no shell)
  #
  #
  # In the first form, the string is taken as a command line that is subject to
  # shell expansion before being executed.
  #
  # The standard shell always means `"/bin/sh"` on Unix-like systems, otherwise,
  # `ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows and similar.  The command is
  # passed as an argument to the `"-c"` switch to the shell, except in the case of
  # `COMSPEC`.
  #
  # If the string from the first form (`exec("command")`) follows these simple
  # rules:
  #
  # *   no meta characters,
  # *   not starting with shell reserved word or special built-in,
  #
  #
  # Ruby invokes the command directly without shell.
  #
  # You can force shell invocation by adding ";" to the string (because ";" is a
  # meta character).
  #
  # Note that this behavior is observable by pid obtained (return value of spawn()
  # and IO#pid for IO.popen) is the pid of the invoked command, not shell.
  #
  # In the second form (`exec("command1", "arg1", ...)`), the first is taken as a
  # command name and the rest are passed as parameters to command with no shell
  # expansion.
  #
  # In the third form (`exec(["command", "argv0"], "arg1", ...)`), starting a
  # two-element array at the beginning of the command, the first element is the
  # command to be executed, and the second argument is used as the `argv[0]`
  # value, which may show up in process listings.
  #
  # In order to execute the command, one of the `exec(2)` system calls are used,
  # so the running command may inherit some of the environment of the original
  # program (including open file descriptors).
  #
  # This behavior is modified by the given `env` and `options` parameters. See
  # ::spawn for details.
  #
  # If the command fails to execute (typically Errno::ENOENT when it was not
  # found) a SystemCallError exception is raised.
  #
  # This method modifies process attributes according to given `options` before
  # `exec(2)` system call. See ::spawn for more details about the given `options`.
  #
  # The modified attributes may be retained when `exec(2)` system call fails.
  #
  # For example, hard resource limits are not restorable.
  #
  # Consider to create a child process using ::spawn or Kernel#system if this is
  # not acceptable.
  #
  #     exec "echo *"       # echoes list of files in current directory
  #     # never get here
  #
  #     exec "echo", "*"    # echoes an asterisk
  #     # never get here
  #

  # def self?.exec: (
  #   ?Hash[string, string]? env,
  #   [string, string] | string prog_arg0,
  #   *string args,
  #   ?Hash[Symbol | redirect_key, bool? | int | path | redirect_val] opts,
  # ) -> bot
  # | (
  #   ?Hash[string, string]? env,
  #   [string, string] | string prog_arg0,
  #   *string args,
  #   ?pgroup: int | bool?,
  #   ?unsetenv_others: bool?,
  #   ?chdir: path,
  #   ?umask: int,
  #   ?close_others: bool?,
  #   ?in: redirect_val,
  #   ?out: redirect_val,
  #   ?err: redirect_val,
  #   ?uid: string | int,
  #   ?gid: string | int,
  #   ?exception: bool?,
  #   **redirect_key => redirect_val opts
  # ) -> bot

  # def self?.exec
  #   : (string prog, *string args, ?Hash[Symbol | redirect_key, bool? | int | path | redirect_val] opts) -> bot
  #   | ([string, string] prog_arg0, *string args, ?Hash[Symbol | redirect_key, bool? | int | path | redirect_val] opts) -> bot
  #   : (
  #     [string, string] | string prog_maybe_arg0,
  #     *string args,
  #     **(redirect_key => redirect_key)
  #     # ?Hash[Symbol | redirect_key, bool? | int | path | string | redirect_val] opts
  #   ) -> bot
  #   | ([string, string] prog_arg0, *string args, ?Hash[Symbol | redirect_key, bool? | int | path | string | redirect_val] opts) -> bot

  #   ?Hash[string, string?] env,
  #   ([string, string] | string) maybe_prog_also_arg0, # Technically is an `array[string]` that's convertible into length 2.
  #   *string args,
  #   ?Hash[Symbol | redirect_key, bool? | int | path | string | redirect_val] opts) -> bot
  #  | (
  #   ?Hash[string, string?] env,
  #   ([string, string] | string) maybe_prog_also_arg0, # Technically is an `array[string]` that's convertible into length 2.
  #   *string args,

  #   ?Hash[redirect_key, redirect_val] opts
  #   ?pgroup: bool? | int,
  #   ?unsetenv_others: bool?,
  #   ?chdir: path,
  #   ?umask: int,
  #   ?close_others: bool?,
  #   ?in: redirect_val,
  #   ?out: redirect_val,
  #   ?err: redirect_val,
  #   ?uid: string | int,
  #   ?gid: string | int,
  #   ?exception: bool?) -> bot

  #  # TODO: HAVE_SETRLIMIT
  # type redirect_key = :in | :out | :err | Integer | io
  # type redirect_val = :close | :in | :out | :err | File | Integer | String | io | [:child, redirect_key] | [path, String | int?] | [path, String | int?, int]

  # def self?.exec
  # # : (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> bot
  # #               | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> bot
  #  : (
  #   ?Hash[string, string?] env,
  #   ([string, string] | string) maybe_prog_also_arg0, # Technically is an `array[string]` that's convertible into length 2.
  #   *string args,
  #   ?Hash[Symbol | redirect_key, bool? | int | path | string | redirect_val] opts) -> bot
  #  | (
  #   ?Hash[string, string?] env,
  #   ([string, string] | string) maybe_prog_also_arg0, # Technically is an `array[string]` that's convertible into length 2.
  #   *string args,

  #   ?Hash[redirect_key, redirect_val] opts
  #   ?pgroup: bool? | int,
  #   ?unsetenv_others: bool?,
  #   ?chdir: path,
  #   ?umask: int,
  #   ?close_others: bool?,
  #   ?in: redirect_val,
  #   ?out: redirect_val,
  #   ?err: redirect_val,
  #   ?uid: string | int,
  #   ?gid: string | int,
  #   ?exception: bool?) -> bot

  #  # TODO: HAVE_SETRLIMIT
  # type redirect_key = :in | :out | :err | Integer | io
  # type redirect_val = :close | :in | :out | :err | File | Integer | String | io | [:child, redirect_key] | [path, String | nil | int] | [path, String | nil | int, int]

  # <!--
  #   rdoc-file=process.c
  #   - spawn([env,] command... [,options])     -> pid
  #   - Process.spawn([env,] command... [,options])     -> pid
  # -->
  # spawn executes specified command and return its pid.
  #
  #     pid = spawn("tar xf ruby-2.0.0-p195.tar.bz2")
  #     Process.wait pid
  #
  #     pid = spawn(RbConfig.ruby, "-eputs'Hello, world!'")
  #     Process.wait pid
  #
  # This method is similar to Kernel#system but it doesn't wait for the command to
  # finish.
  #
  # The parent process should use Process.wait to collect the termination status
  # of its child or use Process.detach to register disinterest in their status;
  # otherwise, the operating system may accumulate zombie processes.
  #
  # spawn has bunch of options to specify process attributes:
  #
  #     env: hash
  #       name => val : set the environment variable
  #       name => nil : unset the environment variable
  #
  #       the keys and the values except for +nil+ must be strings.
  #     command...:
  #       commandline                 : command line string which is passed to the standard shell
  #       cmdname, arg1, ...          : command name and one or more arguments (This form does not use the shell. See below for caveats.)
  #       [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)
  #     options: hash
  #       clearing environment variables:
  #         :unsetenv_others => true   : clear environment variables except specified by env
  #         :unsetenv_others => false  : don't clear (default)
  #       process group:
  #         :pgroup => true or 0 : make a new process group
  #         :pgroup => pgid      : join the specified process group
  #         :pgroup => nil       : don't change the process group (default)
  #       create new process group: Windows only
  #         :new_pgroup => true  : the new process is the root process of a new process group
  #         :new_pgroup => false : don't create a new process group (default)
  #       resource limit: resourcename is core, cpu, data, etc.  See Process.setrlimit.
  #         :rlimit_resourcename => limit
  #         :rlimit_resourcename => [cur_limit, max_limit]
  #       umask:
  #         :umask => int
  #       redirection:
  #         key:
  #           FD              : single file descriptor in child process
  #           [FD, FD, ...]   : multiple file descriptor in child process
  #         value:
  #           FD                        : redirect to the file descriptor in parent process
  #           string                    : redirect to file with open(string, "r" or "w")
  #           [string]                  : redirect to file with open(string, File::RDONLY)
  #           [string, open_mode]       : redirect to file with open(string, open_mode, 0644)
  #           [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)
  #           [:child, FD]              : redirect to the redirected file descriptor
  #           :close                    : close the file descriptor in child process
  #         FD is one of follows
  #           :in     : the file descriptor 0 which is the standard input
  #           :out    : the file descriptor 1 which is the standard output
  #           :err    : the file descriptor 2 which is the standard error
  #           integer : the file descriptor of specified the integer
  #           io      : the file descriptor specified as io.fileno
  #       file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not
  #         :close_others => false  : inherit
  #       current directory:
  #         :chdir => str
  #
  # The `cmdname, arg1, ...` form does not use the shell. However, on different
  # OSes, different things are provided as built-in commands. An example of this
  # is +'echo'+, which is a built-in on Windows, but is a normal program on Linux
  # and Mac OS X. This means that `Process.spawn 'echo', '%Path%'` will display
  # the contents of the `%Path%` environment variable on Windows, but
  # `Process.spawn 'echo', '$PATH'` prints the literal `$PATH`.
  #
  # If a hash is given as `env`, the environment is updated by `env` before
  # `exec(2)` in the child process. If a pair in `env` has nil as the value, the
  # variable is deleted.
  #
  #     # set FOO as BAR and unset BAZ.
  #     pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)
  #
  # If a hash is given as `options`, it specifies process group, create new
  # process group, resource limit, current directory, umask and redirects for the
  # child process. Also, it can be specified to clear environment variables.
  #
  # The `:unsetenv_others` key in `options` specifies to clear environment
  # variables, other than specified by `env`.
  #
  #     pid = spawn(command, :unsetenv_others=>true) # no environment variable
  #     pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only
  #
  # The `:pgroup` key in `options` specifies a process group. The corresponding
  # value should be true, zero, a positive integer, or nil. true and zero cause
  # the process to be a process leader of a new process group. A non-zero positive
  # integer causes the process to join the provided process group. The default
  # value, nil, causes the process to remain in the same process group.
  #
  #     pid = spawn(command, :pgroup=>true) # process leader
  #     pid = spawn(command, :pgroup=>10) # belongs to the process group 10
  #
  # The `:new_pgroup` key in `options` specifies to pass
  # `CREATE_NEW_PROCESS_GROUP` flag to `CreateProcessW()` that is Windows API.
  # This option is only for Windows. true means the new process is the root
  # process of the new process group. The new process has CTRL+C disabled. This
  # flag is necessary for `Process.kill(:SIGINT, pid)` on the subprocess.
  # :new_pgroup is false by default.
  #
  #     pid = spawn(command, :new_pgroup=>true)  # new process group
  #     pid = spawn(command, :new_pgroup=>false) # same process group
  #
  # The `:rlimit_`*foo* key specifies a resource limit. *foo* should be one of
  # resource types such as `core`. The corresponding value should be an integer or
  # an array which have one or two integers: same as cur_limit and max_limit
  # arguments for Process.setrlimit.
  #
  #     cur, max = Process.getrlimit(:CORE)
  #     pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.
  #     pid = spawn(command, :rlimit_core=>max) # enable core dump
  #     pid = spawn(command, :rlimit_core=>0) # never dump core.
  #
  # The `:umask` key in `options` specifies the umask.
  #
  #     pid = spawn(command, :umask=>077)
  #
  # The :in, :out, :err, an integer, an IO and an array key specifies a
  # redirection. The redirection maps a file descriptor in the child process.
  #
  # For example, stderr can be merged into stdout as follows:
  #
  #     pid = spawn(command, :err=>:out)
  #     pid = spawn(command, 2=>1)
  #     pid = spawn(command, STDERR=>:out)
  #     pid = spawn(command, STDERR=>STDOUT)
  #
  # The hash keys specifies a file descriptor in the child process started by
  # #spawn. :err, 2 and STDERR specifies the standard error stream (stderr).
  #
  # The hash values specifies a file descriptor in the parent process which
  # invokes #spawn. :out, 1 and STDOUT specifies the standard output stream
  # (stdout).
  #
  # In the above example, the standard output in the child process is not
  # specified. So it is inherited from the parent process.
  #
  # The standard input stream (stdin) can be specified by :in, 0 and STDIN.
  #
  # A filename can be specified as a hash value.
  #
  #     pid = spawn(command, :in=>"/dev/null") # read mode
  #     pid = spawn(command, :out=>"/dev/null") # write mode
  #     pid = spawn(command, :err=>"log") # write mode
  #     pid = spawn(command, [:out, :err]=>"/dev/null") # write mode
  #     pid = spawn(command, 3=>"/dev/null") # read mode
  #
  # For stdout and stderr (and combination of them), it is opened in write mode.
  # Otherwise read mode is used.
  #
  # For specifying flags and permission of file creation explicitly, an array is
  # used instead.
  #
  #     pid = spawn(command, :in=>["file"]) # read mode is assumed
  #     pid = spawn(command, :in=>["file", "r"])
  #     pid = spawn(command, :out=>["log", "w"]) # 0644 assumed
  #     pid = spawn(command, :out=>["log", "w", 0600])
  #     pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT, 0600])
  #
  # The array specifies a filename, flags and permission. The flags can be a
  # string or an integer. If the flags is omitted or nil, File::RDONLY is assumed.
  # The permission should be an integer. If the permission is omitted or nil, 0644
  # is assumed.
  #
  # If an array of IOs and integers are specified as a hash key, all the elements
  # are redirected.
  #
  #     # stdout and stderr is redirected to log file.
  #     # The file "log" is opened just once.
  #     pid = spawn(command, [:out, :err]=>["log", "w"])
  #
  # Another way to merge multiple file descriptors is [:child, fd]. [:child, fd]
  # means the file descriptor in the child process. This is different from fd. For
  # example, :err=>:out means redirecting child stderr to parent stdout. But
  # :err=>[:child, :out] means redirecting child stderr to child stdout. They
  # differ if stdout is redirected in the child process as follows.
  #
  #     # stdout and stderr is redirected to log file.
  #     # The file "log" is opened just once.
  #     pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])
  #
  # [:child, :out] can be used to merge stderr into stdout in IO.popen. In this
  # case, IO.popen redirects stdout to a pipe in the child process and [:child,
  # :out] refers the redirected stdout.
  #
  #     io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])
  #     p io.read #=> "out\nerr\n"
  #
  # The `:chdir` key in `options` specifies the current directory.
  #
  #     pid = spawn(command, :chdir=>"/var/tmp")
  #
  # spawn closes all non-standard unspecified descriptors by default. The
  # "standard" descriptors are 0, 1 and 2. This behavior is specified by
  # :close_others option. :close_others doesn't affect the standard descriptors
  # which are closed only if :close is specified explicitly.
  #
  #     pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)
  #     pid = spawn(command, :close_others=>false) # don't close 3,4,5,...
  #
  # :close_others is false by default for spawn and IO.popen.
  #
  # Note that fds which close-on-exec flag is already set are closed regardless of
  # :close_others option.
  #
  # So IO.pipe and spawn can be used as IO.popen.
  #
  #     # similar to r = IO.popen(command)
  #     r, w = IO.pipe
  #     pid = spawn(command, :out=>w)   # r, w is closed in the child process.
  #     w.close
  #
  # :close is specified as a hash value to close a fd individually.
  #
  #     f = open(foo)
  #     system(command, f=>:close)        # don't inherit f.
  #
  # If a file descriptor need to be inherited, io=>io can be used.
  #
  #     # valgrind has --log-fd option for log destination.
  #     # log_w=>log_w indicates log_w.fileno inherits to child process.
  #     log_r, log_w = IO.pipe
  #     pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a", log_w=>log_w)
  #     log_w.close
  #     p log_r.read
  #
  # It is also possible to exchange file descriptors.
  #
  #     pid = spawn(command, :out=>:err, :err=>:out)
  #
  # The hash keys specify file descriptors in the child process. The hash values
  # specifies file descriptors in the parent process. So the above specifies
  # exchanging stdout and stderr. Internally, `spawn` uses an extra file
  # descriptor to resolve such cyclic file descriptor mapping.
  #
  # See Kernel.exec for the standard shell.
  #
  def self?.spawn: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer
                 | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - system([env,] command... [,options], exception: false)    -> true, false or nil
  # -->
  # Executes *command...* in a subshell. *command...* is one of following forms.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # `commandline`
  # :   command line string which is passed to the standard shell
  # `cmdname, arg1, ...`
  # :   command name and one or more arguments (no shell)
  # `[cmdname, argv0], arg1, ...`
  # :   command name, `argv[0]` and zero or more arguments (no shell)
  #
  #
  # system returns `true` if the command gives zero exit status, `false` for non
  # zero exit status. Returns `nil` if command execution fails. An error status is
  # available in `$?`.
  #
  # If the `exception: true` argument is passed, the method raises an exception
  # instead of returning `false` or `nil`.
  #
  # The arguments are processed in the same way as for Kernel#spawn.
  #
  # The hash arguments, env and options, are same as #exec and #spawn. See
  # Kernel#spawn for details.
  #
  #     system("echo *")
  #     system("echo", "*")
  #
  # *produces:*
  #
  #     config.h main.rb
  #     *
  #
  # Error handling:
  #
  #     system("cat nonexistent.txt")
  #     # => false
  #     system("catt nonexistent.txt")
  #     # => nil
  #
  #     system("cat nonexistent.txt", exception: true)
  #     # RuntimeError (Command failed with exit 1: cat)
  #     system("catt nonexistent.txt", exception: true)
  #     # Errno::ENOENT (No such file or directory - catt)
  #
  # See Kernel#exec for the standard shell.
  #
  def self?.system: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> (NilClass | FalseClass | TrueClass)
                  | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> (NilClass | FalseClass | TrueClass)

  # <!--
  #   rdoc-file=object.c
  #   - obj !~ other  -> true or false
  # -->
  # Returns true if two objects do not match (using the *=~* method), otherwise
  # false.
  #
  def !~: [T] (T other) -> bool #where self < _Match[T, untyped]

  # interface _Match[I, O]
  #   def =~: (I) -> O
  # end

  # <!--
  #   rdoc-file=object.c
  #   - obj <=> other -> 0 or nil
  # -->
  # Returns 0 if `obj` and `other` are the same object or `obj == other`,
  # otherwise nil.
  #
  # The #<=> is used by various methods to compare objects, for example
  # Enumerable#sort, Enumerable#max etc.
  #
  # Your implementation of #<=> should return one of the following values: -1, 0,
  # 1 or nil. -1 means self is smaller than other. 0 means self is equal to other.
  # 1 means self is bigger than other. Nil means the two values could not be
  # compared.
  #
  # When you define #<=>, you can include Comparable to gain the methods #<=, #<,
  # #==, #>=, #> and #between?.
  #
  def <=>: (untyped other) -> 0?

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.class    -> class
  # -->
  # Returns the class of *obj*. This method must always be called with an explicit
  # receiver, as #class is also a reserved word in Ruby.
  #
  #     1.class      #=> Integer
  #     self.class   #=> Object
  #
  def class: () -> Class

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.clone(freeze: nil) -> an_object
  # -->
  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. #clone copies the frozen value state of
  # *obj*, unless the `:freeze` keyword argument is given with a false or true
  # value. See also the discussion under Object#dup.
  #
  #     class Klass
  #        attr_accessor :str
  #     end
  #     s1 = Klass.new      #=> #<Klass:0x401b3a38>
  #     s1.str = "Hello"    #=> "Hello"
  #     s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
  #     s2.str[1,4] = "i"   #=> "i"
  #     s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
  #     s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  def clone: (?freeze: bool?) -> instance

  # <!--
  #   rdoc-file=proc.c
  #   - define_singleton_method(symbol, method) -> symbol
  #   - define_singleton_method(symbol) { block } -> symbol
  # -->
  # Defines a public singleton method in the receiver. The *method* parameter can
  # be a `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified,
  # it is used as the method body. If a block or a method has parameters, they're
  # used as method parameters.
  #
  #     class A
  #       class << self
  #         def class_name
  #           to_s
  #         end
  #       end
  #     end
  #     A.define_singleton_method(:who_am_i) do
  #       "I am: #{class_name}"
  #     end
  #     A.who_am_i   # ==> "I am: A"
  #
  #     guy = "Bob"
  #     guy.define_singleton_method(:hello) { "#{self}: Hello there!" }
  #     guy.hello    #=>  "Bob: Hello there!"
  #
  #     chris = "Chris"
  #     chris.define_singleton_method(:greet) {|greeting| "#{greeting}, I'm Chris!" }
  #     chris.greet("Hi") #=> "Hi, I'm Chris!"
  #
  def define_singleton_method: (interned name, Method | UnboundMethod | Proc method) -> Symbol
                             | (interned name) { (*untyped) -> untyped } -> Symbol

  # <!--
  #   rdoc-file=io.c
  #   - display(port = $>) -> nil
  # -->
  # Writes `self` on the given port:
  #
  #     1.display
  #     "cat".display
  #     [ 4, 5, 6 ].display
  #     puts
  #
  # Output:
  #
  #     1cat[4, 5, 6]
  #
  def display: (?_Writer port) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - obj.dup -> an_object
  # -->
  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference.
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  # ### on dup vs clone
  #
  # In general, #clone and #dup may have different semantics in descendant
  # classes. While #clone is used to duplicate an object, including its internal
  # state, #dup typically uses the class of the descendant object to create the
  # new instance.
  #
  # When using #dup, any modules that the object has been extended with will not
  # be copied.
  #
  #     class Klass
  #       attr_accessor :str
  #     end
  #
  #     module Foo
  #       def foo; 'foo'; end
  #     end
  #
  #     s1 = Klass.new #=> #<Klass:0x401b3a38>
  #     s1.extend(Foo) #=> #<Klass:0x401b3a38>
  #     s1.foo #=> "foo"
  #
  #     s2 = s1.clone #=> #<Klass:0x401be280>
  #     s2.foo #=> "foo"
  #
  #     s3 = s1.dup #=> #<Klass:0x401c1084>
  #     s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401c1084>
  #
  def dup: () -> instance

  # <!-- rdoc-file=enumerator.c -->
  # Creates a new Enumerator which will enumerate by calling `method` on `obj`,
  # passing `args` if any. What was *yielded* by method becomes values of
  # enumerator.
  #
  # If a block is given, it will be used to calculate the size of the enumerator
  # without the need to iterate it (see Enumerator#size).
  #
  # ### Examples
  #
  #     str = "xyz"
  #
  #     enum = str.enum_for(:each_byte)
  #     enum.each { |b| puts b }
  #     # => 120
  #     # => 121
  #     # => 122
  #
  #     # protect an array from being modified by some_method
  #     a = [1, 2, 3]
  #     some_method(a.to_enum)
  #
  #     # String#split in block form is more memory-effective:
  #     very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
  #     # This could be rewritten more idiomatically with to_enum:
  #     very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first
  #
  # It is typical to call to_enum when defining methods for a generic Enumerable,
  # in case no block is passed.
  #
  # Here is such an example, with parameter passing and a sizing block:
  #
  #     module Enumerable
  #       # a generic method to repeat the values of any enumerable
  #       def repeat(n)
  #         raise ArgumentError, "#{n} is negative!" if n < 0
  #         unless block_given?
  #           return to_enum(__method__, n) do # __method__ is :repeat here
  #             sz = size     # Call size and multiply by n...
  #             sz * n if sz  # but return nil if size itself is nil
  #           end
  #         end
  #         each do |*val|
  #           n.times { yield *val }
  #         end
  #       end
  #     end
  #
  #     %i[hello world].repeat(2) { |w| puts w }
  #       # => Prints 'hello', 'hello', 'world', 'world'
  #     enum = (1..14).repeat(3)
  #       # => returns an Enumerator when called without a block
  #     enum.first(4) # => [1, 1, 1, 2]
  #     enum.size # => 42
  #
  def enum_for: (Symbol method, *untyped, **untyped) ?{ (*untyped, **untyped) -> Integer } -> Enumerator[untyped, untyped]
              | () ?{ () -> Integer } -> Enumerator[untyped, self]
 # if no method is given, defaults to `each`
 # size is enum's yield
 # ^ todo
  %a{annotate:rdoc:skip}
  alias to_enum enum_for

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - obj.extend(module, ...)    -> obj
  # -->
  # Adds to *obj* the instance methods from each module given as a parameter.
  #
  #     module Mod
  #       def hello
  #         "Hello from Mod.\n"
  #       end
  #     end
  #
  #     class Klass
  #       def hello
  #         "Hello from Klass.\n"
  #       end
  #     end
  #
  #     k = Klass.new
  #     k.hello         #=> "Hello from Klass.\n"
  #     k.extend(Mod)   #=> #<Klass:0x401b3bc8>
  #     k.hello         #=> "Hello from Mod.\n"
  #
  def extend: (*Module modules) -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.freeze    -> obj
  # -->
  # Prevents further modifications to *obj*. A FrozenError will be raised if
  # modification is attempted. There is no way to unfreeze a frozen object. See
  # also Object#frozen?.
  #
  # This method returns self.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze
  #     a << "z"
  #
  # *produces:*
  #
  #     prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
  #      from prog.rb:3
  #
  # Objects of the following classes are always frozen: Integer, Float, Symbol.
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.frozen?    -> true or false
  # -->
  # Returns the freeze status of *obj*.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze    #=> ["a", "b", "c"]
  #     a.frozen?   #=> true
  #
  def frozen?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.hash    -> integer
  # -->
  # Generates an Integer hash value for this object.  This function must have the
  # property that `a.eql?(b)` implies `a.hash == b.hash`.
  #
  # The hash value is used along with #eql? by the Hash class to determine if two
  # objects reference the same hash key.  Any hash value that exceeds the capacity
  # of an Integer will be truncated before being used.
  #
  # The hash value for an object may not be identical across invocations or
  # implementations of Ruby.  If you need a stable identifier across Ruby
  # invocations and implementations you will need to generate one with a custom
  # method.
  #
  # Certain core classes such as Integer use built-in hash calculations and do not
  # call the #hash method when used as a hash key.
  #
  # When implementing your own #hash based on multiple values, the best practice
  # is to combine the class and any values using the hash code of an array:
  #
  # For example:
  #
  #     def hash
  #       [self.class, a, b, c].hash
  #     end
  #
  # The reason for this is that the Array#hash method already has logic for safely
  # and efficiently combining multiple hash values.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - obj.inspect   -> string
  # -->
  # Returns a string containing a human-readable representation of *obj*. The
  # default #inspect shows the object's class name, an encoding of its memory
  # address, and a list of the instance variables and their values (by calling
  # #inspect on each of them).  User defined classes should override this method
  # to provide a better representation of *obj*.  When overriding this method, it
  # should return a string whose encoding is compatible with the default external
  # encoding.
  #
  #     [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"
  #     Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
  #
  #     class Foo
  #     end
  #     Foo.new.inspect                  #=> "#<Foo:0x0300c868>"
  #
  #     class Bar
  #       def initialize
  #         @bar = 1
  #       end
  #     end
  #     Bar.new.inspect                  #=> "#<Bar:0x0300c868 @bar=1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_of?(class)    -> true or false
  # -->
  # Returns `true` if *obj* is an instance of the given class. See also
  # Object#kind_of?.
  #
  #     class A;     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.instance_of? A   #=> false
  #     b.instance_of? B   #=> true
  #     b.instance_of? C   #=> false
  #
  def instance_of?: (Module module_or_class) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_defined?(symbol)    -> true or false
  #   - obj.instance_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given instance variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_defined?(:@a)    #=> true
  #     fred.instance_variable_defined?("@b")   #=> true
  #     fred.instance_variable_defined?("@c")   #=> false
  #
  def instance_variable_defined?: (interned name) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_get(symbol)    -> obj
  #   - obj.instance_variable_get(string)    -> obj
  # -->
  # Returns the value of the given instance variable, or nil if the instance
  # variable is not set. The `@` part of the variable name should be included for
  # regular instance variables. Throws a NameError exception if the supplied
  # symbol is not valid as an instance variable name. String arguments are
  # converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_get(:@a)    #=> "cat"
  #     fred.instance_variable_get("@b")   #=> 99
  #
  def instance_variable_get: (interned name) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_set(symbol, obj)    -> obj
  #   - obj.instance_variable_set(string, obj)    -> obj
  # -->
  # Sets the instance variable named by *symbol* to the given object. This may
  # circumvent the encapsulation intended by the author of the class, so it should
  # be used with care. The variable does not have to exist prior to this call. If
  # the instance variable name is passed as a string, that string is converted to
  # a symbol.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_set(:@a, 'dog')   #=> "dog"
  #     fred.instance_variable_set(:@c, 'cat')   #=> "cat"
  #     fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\">"
  #
  def instance_variable_set: [T] (interned name, T value) -> T

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variables    -> array
  # -->
  # Returns an array of instance variable names for the receiver. Note that simply
  # defining an accessor does not create the corresponding instance variable.
  #
  #     class Fred
  #       attr_accessor :a1
  #       def initialize
  #         @iv = 3
  #       end
  #     end
  #     Fred.new.instance_variables   #=> [:@iv]
  #
  def instance_variables: () -> Array[Symbol]

  # <!-- rdoc-file=object.c -->
  # Returns `true` if *class* is the class of *obj*, or if *class* is one of the
  # superclasses of *obj* or modules included in *obj*.
  #
  #     module M;    end
  #     class A
  #       include M
  #     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.is_a? A          #=> true
  #     b.is_a? B          #=> true
  #     b.is_a? C          #=> false
  #     b.is_a? M          #=> true
  #
  #     b.kind_of? A       #=> true
  #     b.kind_of? B       #=> true
  #     b.kind_of? C       #=> false
  #     b.kind_of? M       #=> true
  #
  def is_a?: (Module class_or_module) -> bool

  %a{annotate:rdoc:skip}
  alias kind_of? is_a?

  # <!--
  #   rdoc-file=object.c
  #   - obj.itself    -> obj
  # -->
  # Returns the receiver.
  #
  #     string = "my string"
  #     string.itself.object_id == string.object_id   #=> true
  #
  def itself: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - obj.method(sym)    -> method
  # -->
  # Looks up the named method as a receiver in *obj*, returning a Method object
  # (or raising NameError). The Method object acts as a closure in *obj*'s object
  # instance, so instance variables and the value of `self` remain available.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     m = k.method(:hello)
  #     m.call   #=> "Hello, @iv = 99"
  #
  #     l = Demo.new('Fred')
  #     m = l.method("hello")
  #     m.call   #=> "Hello, @iv = Fred"
  #
  # Note that Method implements `to_proc` method, which means it can be used with
  # iterators.
  #
  #     [ 1, 2, 3 ].each(&method(:puts)) # => prints 3 lines to stdout
  #
  #     out = File.open('test.txt', 'w')
  #     [ 1, 2, 3 ].each(&out.method(:puts)) # => prints 3 lines to file
  #
  #     require 'date'
  #     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
  #     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
  #
  def method: (interned name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.methods(regular=true)    -> array
  # -->
  # Returns a list of the names of public and protected methods of *obj*. This
  # will include all the methods accessible in *obj*'s ancestors. If the optional
  # parameter is `false`, it returns an array of *obj*'s public and protected
  # singleton methods, the array will not include methods in modules included in
  # *obj*.
  #
  #     class Klass
  #       def klass_method()
  #       end
  #     end
  #     k = Klass.new
  #     k.methods[0..9]    #=> [:klass_method, :nil?, :===,
  #                        #    :==~, :!, :eql?
  #                        #    :hash, :<=>, :class, :singleton_class]
  #     k.methods.length   #=> 56
  #
  #     k.methods(false)   #=> []
  #     def k.singleton_method; end
  #     k.methods(false)   #=> [:singleton_method]
  #
  #     module M123; def m123; end end
  #     k.extend M123
  #     k.methods(false)   #=> [:singleton_method]
  #
  def methods: (?boolish include_super) -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.nil?               -> true or false
  # -->
  # Only the object *nil* responds `true` to `nil?`.
  #
  #     Object.new.nil?   #=> false
  #     nil.nil?          #=> true
  #
  def nil?: () -> false

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements +__id__+, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  alias object_id __id__

  # <!--
  #   rdoc-file=object.c
  #   - obj.private_methods(all=true)   -> array
  # -->
  # Returns the list of private methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def private_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.protected_methods(all=true)   -> array
  # -->
  # Returns the list of protected methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def protected_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - obj.public_method(sym)    -> method
  # -->
  # Similar to *method*, searches public method only.
  #
  def public_method: (interned name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.public_methods(all=true)   -> array
  # -->
  # Returns the list of public methods accessible to *obj*. If the *all* parameter
  # is set to `false`, only those methods in the receiver will be listed.
  #
  def public_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.public_send(symbol [, args...])  -> obj
  #   - obj.public_send(string [, args...])  -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # Unlike send, public_send calls public methods only. When the method is
  # identified by a string, the string is converted to a symbol.
  #
  #     1.public_send(:puts, "hello")  # causes NoMethodError
  #
  def public_send: (interned name, *untyped args) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.remove_instance_variable(symbol)    -> obj
  #   - obj.remove_instance_variable(string)    -> obj
  # -->
  # Removes the named instance variable from *obj*, returning that variable's
  # value. String arguments are converted to symbols.
  #
  #     class Dummy
  #       attr_reader :var
  #       def initialize
  #         @var = 99
  #       end
  #       def remove
  #         remove_instance_variable(:@var)
  #       end
  #     end
  #     d = Dummy.new
  #     d.var      #=> 99
  #     d.remove   #=> 99
  #     d.var      #=> nil
  #
  def remove_instance_variable: (interned name) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - obj.respond_to?(symbol, include_all=false) -> true or false
  #   - obj.respond_to?(string, include_all=false) -> true or false
  # -->
  # Returns `true` if *obj* responds to the given method.  Private and protected
  # methods are included in the search only if the optional second parameter
  # evaluates to `true`.
  #
  # If the method is not implemented, as Process.fork on Windows, File.lchmod on
  # GNU/Linux, etc., false is returned.
  #
  # If the method is not defined, `respond_to_missing?` method is called and the
  # result is returned.
  #
  # When the method name parameter is given as a string, the string is converted
  # to a symbol.
  #
  def respond_to?: (interned name, ?boolish include_all) -> boolish
  # ^ repsonds with boolish via # c=Class.new{def respond_to_missing?(*)=:lol}.new; p c.respond_to? "a{3}"

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  alias send __send__

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_class    -> class
  # -->
  # Returns the singleton class of *obj*.  This method creates a new singleton
  # class if *obj* does not have one.
  #
  # If *obj* is `nil`, `true`, or `false`, it returns NilClass, TrueClass, or
  # FalseClass, respectively. If *obj* is an Integer, a Float or a Symbol, it
  # raises a TypeError.
  #
  #     Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>
  #     String.singleton_class      #=> #<Class:String>
  #     nil.singleton_class         #=> NilClass
  #
  def singleton_class: () -> Class

  # <!--
  #   rdoc-file=proc.c
  #   - obj.singleton_method(sym)    -> method
  # -->
  # Similar to *method*, searches singleton method only.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     def k.hi
  #       "Hi, @iv = #{@iv}"
  #     end
  #     m = k.singleton_method(:hi)
  #     m.call   #=> "Hi, @iv = 99"
  #     m = k.singleton_method(:hello) #=> NameError
  #
  def singleton_method: (interned name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_methods(all=true)    -> array
  # -->
  # Returns an array of the names of singleton methods for *obj*. If the optional
  # *all* parameter is true, the list will include methods in modules included in
  # *obj*. Only public and protected singleton methods are returned.
  #
  #     module Other
  #       def three() end
  #     end
  #
  #     class Single
  #       def Single.four() end
  #     end
  #
  #     a = Single.new
  #
  #     def a.one()
  #     end
  #
  #     class << a
  #       include Other
  #       def two()
  #       end
  #     end
  #
  #     Single.singleton_methods    #=> [:four]
  #     a.singleton_methods(false)  #=> [:two, :one]
  #     a.singleton_methods         #=> [:two, :one, :three]
  #
  def singleton_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.tap {|x| block }    -> obj
  # -->
  # Yields self to the block, and then returns self. The primary purpose of this
  # method is to "tap into" a method chain, in order to perform operations on
  # intermediate results within the chain.
  #
  #     (1..10)                  .tap {|x| puts "original: #{x}" }
  #       .to_a                  .tap {|x| puts "array:    #{x}" }
  #       .select {|x| x.even? } .tap {|x| puts "evens:    #{x}" }
  #       .map {|x| x*x }        .tap {|x| puts "squares:  #{x}" }
  #
  def tap: () { (self) -> void } -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.to_s    -> string
  # -->
  # Returns a string representing *obj*. The default #to_s prints the object's
  # class and an encoding of the object id. As a special case, the top-level
  # object that is the initial execution context of Ruby programs returns
  # ``main''.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.yield_self {|x| block }    -> an_object
  # -->
  # Yields self to the block and returns the result of the block.
  #
  #     "my string".yield_self {|s| s.upcase }   #=> "MY STRING"
  #
  # Good usage for `then` is value piping in method chains:
  #
  #     require 'open-uri'
  #     require 'json'
  #
  #     construct_url(arguments).
  #       then {|url| URI(url).read }.
  #       then {|response| JSON.parse(response) }
  #
  def yield_self: [T] () { (self) -> T } -> T
                | () -> Enumerator[self, untyped]

  %a{annotate:rdoc:skip}
  alias then yield_self

  private

  # <!--
  #   rdoc-file=vm_method.c
  #   - obj.respond_to_missing?(symbol, include_all) -> true or false
  #   - obj.respond_to_missing?(string, include_all) -> true or false
  # -->
  # DO NOT USE THIS DIRECTLY.
  #
  # Hook method to return whether the *obj* can respond to *id* method or not.
  #
  # When the method name parameter is given as a string, the string is converted
  # to a symbol.
  #
  # See #respond_to?, and the example of BasicObject.
  #
  %a{annotate:rdoc:copy:Object#respond_to_missing?}
  def respond_to_missing?: (interned name, boolish include_all) -> boolish

  def initialize_copy: (instance object) -> self

  def initialize_clone: (instance object, ?freeze: bool?) -> self

  def initialize_dup: (instance object) -> self
end
