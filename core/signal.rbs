# <!-- rdoc-file=signal.c -->
# Many operating systems allow signals to be sent to running processes. Some
# signals have a defined effect on the process, while others may be trapped at
# the code level and acted upon. For example, your process may trap the USR1
# signal and use it to toggle debugging, and may use TERM to initiate a
# controlled shutdown.
#
#     pid = fork do
#       Signal.trap("USR1") do
#         $debug = !$debug
#         puts "Debug now: #$debug"
#       end
#       Signal.trap("TERM") do
#         puts "Terminating..."
#         shutdown()
#       end
#       # . . . do some work . . .
#     end
#
#     Process.detach(pid)
#
#     # Controlling program:
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("TERM", pid)
#
# *produces:*
#     Debug now: true
#     Debug now: false
#     Terminating...
#
# The list of available signal names and their interpretation is system
# dependent. Signal delivery semantics may also vary between systems; in
# particular signal delivery may not always be reliable.
#
module Signal
  # <!--
  #   rdoc-file=signal.c
  #   - Signal.list -> a_hash
  # -->
  # Returns a list of signal names mapped to the corresponding underlying signal
  # numbers.
  #
  #     Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4, "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11, "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19, "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22, "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28, "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}
  #
  def self?.list: () -> Hash[String, Integer]

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.signame(signo)  ->  string or nil
  # -->
  # Convert signal number to signal name. Returns `nil` if the signo is an invalid
  # signal number.
  #
  #     Signal.trap("INT") { |signo| puts Signal.signame(signo) }
  #     Process.kill("INT", 0)
  #
  # *produces:*
  #
  #     INT
  #
  def self?.signame: (int signo) -> String?

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.trap(signal, command) -> obj
  #   - Signal.trap(signal) { ... } -> obj
  # -->
  # Specifies the handling of signals. Returns the previous handler for the given
  # signal.
  #
  # Argument `signal` is a signal name (a string or symbol such as `SIGALRM` or
  # `SIGUSR1`) or an integer signal number. When `signal` is a string or symbol,
  # the leading characters `SIG` may be omitted.
  #
  # Argument `command` or block provided specifies code to be run when the signal
  # is raised.
  #
  # Argument `command` may also be a string or symbol with the following special
  # values:
  #
  # *   `IGNORE`, `SIG_IGN`: the signal will be ignored.
  # *   `DEFAULT`, `SIG_DFL`: Ruby's default handler will be invoked.
  # *   `EXIT`: the process will be terminated by the signal.
  # *   `SYSTEM_DEFAULT`: the operating system's default handler will be invoked.
  #
  # The special signal name `EXIT` or signal number zero will be invoked just
  # prior to program termination:
  #
  #     Signal.trap(0, proc { puts "Terminating: #{$$}" })
  #     Signal.trap("CLD")  { puts "Child died" }
  #     fork && Process.wait
  #
  # Outputs:
  #
  #     Terminating: 27461
  #     Child died
  #     Terminating: 27460
  #
  def self?.trap: (Integer | interned signal) { (Integer) -> void } -> trap_command
                | (Integer | interned signal, trap_command command) -> trap_command

  type trap_command = string | bool | nil | _TrapCommand

  interface _TrapCommand
    def call: (Integer signo) -> void
  end
end
