#!/usr/bin/env ruby

require "bundler/setup"
require "rbs"
require "rdoc"

def store_for_class(name, stores:)
  stores.find do |store|
    store.find_class_named(name) || store.find_module_named(name)
  end
end

def format_comment(comment)
  out = RDoc::Markup::Document.new
  out << comment
  formatter = RDoc::Markup::ToMarkdown.new
  out.accept(formatter).lines.map(&:rstrip).join("\n")
end

def resolve_name(name, outer:)
  namespace = outer.inject(RBS::Namespace.root) do |ns1, ns2|
    ns1 + ns2
  end + name.namespace

  name.with_prefix(namespace)
end

def comment_for_constant(const_name, stores:)
  class_name =
    if (ns = const_name.namespace).empty?
      TypeName("::Object")
    else
      ns.to_type_name
    end

  klass = store_for_class(class_name.relative!.to_s, stores: stores)&.yield_self {|store|
    store.find_class_named(class_name.relative!.to_s) || store.find_module_named(class_name.relative!.to_s)
  }

  if klass
    constant = klass.constants.find do |const|
      const.name == const_name.name.to_s
    end

    if constant&.documented?
      string = format_comment(constant.comment)
      RBS::AST::Comment.new(location: nil, string: string)
    end
  end
end

def comment_for_class(class_name, stores:)
  name = class_name.relative!.to_s

  klass = store_for_class(name, stores: stores)&.yield_self {|store|
    store.find_class_named(name) || store.find_module_named(name)
  }

  if klass&.documented?
    string = format_comment(klass.comment)
    RBS::AST::Comment.new(location: nil, string: string)
  end
end

def comment_for_method(klass, method, stores:)
  class_name = klass.relative!.to_s
  method = store_for_class(class_name, stores: stores)&.load_method(class_name, method)

  if method&.documented?
    out = RDoc::Markup::Document.new

    out << method.comment

    string = out.accept(RDoc::Markup::ToMarkdown.new)

    if method.arglists
      string << "<!--\n"
      method.arglists.chomp.split("\n").each do |line|
        string << "    #{line}\n"
      end
      string << "-->\n"
    end

    RBS::AST::Comment.new(location: nil, string: string)
  end

rescue RDoc::Store::MissingFileError
  puts "  ðŸ‘º No document found for #{klass}#{method}"
  nil
end

if ARGV.empty?
  puts 'annotate-with-rdoc [RBS files...]'
  exit
end

def print_members(stores, klass_name, members)
  members.each do |member|
    case member
    when RBS::AST::Members::MethodDefinition
      puts "    Processing #{member.name}..."

      method_name = case
                    when member.instance?
                      "##{member.name}"
                    when member.singleton?
                      "::#{member.name}"
                    end

      comment = comment_for_method(klass_name, method_name, stores: stores)

      unless comment
        if member.instance? && member.name == :initialize
          comment = comment_for_method(klass_name, '::new', stores: stores)
        end
      end

      member.instance_variable_set(:@comment, comment)
    when RBS::AST::Members::AttrReader, RBS::AST::Members::AttrAccessor, RBS::AST::Members::AttrWriter
      puts "    ðŸ‘» Attributes not supported (#{klass_name})"
    when RBS::AST::Members::Alias
      puts "    Processing #{member.new_name}(alias)..."
      prefix = case
               when member.instance?
                 "#"
               when member.singleton?
                 "."
               end
      name = "#{prefix}#{member.new_name}"

      comment = comment_for_method(klass_name, name, stores: stores)
      member.instance_variable_set(:@comment, comment)
    end
  end
end

def annotate_declaration(decl:, outer:, stores:)
  case decl
  when RBS::AST::Declarations::Constant
    puts "  Importing documentation for #{decl.name}..."
    const_name = resolve_name(decl.name, outer: outer)
    comment = comment_for_constant(const_name, stores: stores)
    decl.instance_variable_set(:@comment, comment)
  when RBS::AST::Declarations::Class, RBS::AST::Declarations::Module
    class_name = resolve_name(decl.name, outer: outer)

    puts "  Importing documentation for #{class_name}..."
    comment = comment_for_class(class_name, stores: stores)
    decl.instance_variable_set(:@comment, comment)

    print_members(stores, class_name, decl.members)

    outer_ = outer + [decl.name.to_namespace]
    decl.members.each do |member|
      annotate_declaration(decl: member, outer: outer_, stores: stores)
    end
  end
end

stores = []
RDoc::RI::Paths.each true, true, false, false do |path, type|
  puts "Loading store from #{path}..."
  store = RDoc::RI::Store.new(path, type)
  store.load_all
  stores << store
end

ARGV.map {|f| Pathname(f) }.each do |path|
  puts "Opening #{path}..."

  buffer = RBS::Buffer.new(name: path, content: path.read)
  sigs = RBS::Parser.parse_signature(buffer)

  sigs.each do |decl|
    annotate_declaration(decl: decl, outer: [], stores: stores)
  end

  puts "Writing #{path}..."
  path.open('w') do |out|
    writer = RBS::Writer.new(out: out)
    writer.write sigs
  end
end

