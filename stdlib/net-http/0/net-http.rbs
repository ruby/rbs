module Net
  class HTTPBadResponse < StandardError
  end

  class HTTPHeaderSyntaxError < StandardError
  end

  # <!-- rdoc-file=lib/net/http.rb -->
  # Class Net::HTTP provides a rich library that implements the client in a
  # client-server model that uses the HTTP request-response protocol. For
  # information about HTTP, see:
  #
  # *   [Hypertext Transfer
  #     Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  # *   [Technical
  #     overview](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Techni
  #     cal_overview).
  #
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Strategies
  #
  # *   If you will make only a few GET requests, consider using
  #     [OpenURI](rdoc-ref:OpenURI).
  # *   If you will make only a few requests of all kinds, consider using the
  #     various singleton convenience methods in this class. Each of the following
  #     methods automatically starts and finishes a
  #     [session](rdoc-ref:Net::HTTP@Sessions) that sends a single request:
  #
  #         # Return string response body.
  #         Net::HTTP.get(hostname, path)
  #         Net::HTTP.get(uri)
  #
  #         # Write string response body to $stdout.
  #         Net::HTTP.get_print(hostname, path)
  #         Net::HTTP.get_print(uri)
  #
  #         # Return response as Net::HTTPResponse object.
  #         Net::HTTP.get_response(hostname, path)
  #         Net::HTTP.get_response(uri)
  #         data = '{"title": "foo", "body": "bar", "userId": 1}'
  #         Net::HTTP.post(uri, data)
  #         params = {title: 'foo', body: 'bar', userId: 1}
  #         Net::HTTP.post_form(uri, params)
  #
  # *   If performance is important, consider using sessions, which lower request
  #     overhead. This [session](rdoc-ref:Net::HTTP@Sessions) has multiple
  #     requests for [HTTP
  #     methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request
  #     _methods) and [WebDAV
  #     methods](https://en.wikipedia.org/wiki/WebDAV#Implementation):
  #
  #         Net::HTTP.start(hostname) do |http|
  #           # Session started automatically before block execution.
  #           http.get(path)
  #           http.head(path)
  #           body = 'Some text'
  #           http.post(path, body)  # Can also have a block.
  #           http.put(path, body)
  #           http.delete(path)
  #           http.options(path)
  #           http.trace(path)
  #           http.patch(path, body) # Can also have a block.
  #           http.copy(path)
  #           http.lock(path, body)
  #           http.mkcol(path, body)
  #           http.move(path)
  #           http.propfind(path, body)
  #           http.proppatch(path, body)
  #           http.unlock(path, body)
  #           # Session finished automatically at block exit.
  #         end
  #
  #
  # The methods cited above are convenience methods that, via their few arguments,
  # allow minimal control over the requests. For greater control, consider using
  # [request objects](rdoc-ref:Net::HTTPRequest).
  #
  # ## URIs
  #
  # On the internet, a URI ([Universal Resource
  # Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)) is a
  # string that identifies a particular resource. It consists of some or all of:
  # scheme, hostname, path, query, and fragment; see [URI
  # syntax](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax).
  #
  # A Ruby [URI::Generic](rdoc-ref:URI::Generic) object represents an internet
  # URI. It provides, among others, methods `scheme`, `hostname`, `path`, `query`,
  # and `fragment`.
  #
  # ### Schemes
  #
  # An internet URI has a
  # [scheme](https://en.wikipedia.org/wiki/List_of_URI_schemes).
  #
  # The two schemes supported in Net::HTTP are `'https'` and `'http'`:
  #
  #     uri.scheme                       # => "https"
  #     URI('http://example.com').scheme # => "http"
  #
  # ### Hostnames
  #
  # A hostname identifies a server (host) to which requests may be sent:
  #
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     Net::HTTP.start(hostname) do |http|
  #       # Some HTTP stuff.
  #     end
  #
  # ### Paths
  #
  # A host-specific path identifies a resource on the host:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #     hostname = _uri.hostname
  #     path = _uri.path
  #     Net::HTTP.get(hostname, path)
  #
  # ### Queries
  #
  # A host-specific query adds name/value pairs to the URI:
  #
  #     _uri = uri.dup
  #     params = {userId: 1, completed: false}
  #     _uri.query = URI.encode_www_form(params)
  #     _uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com?userId=1&completed=false>
  #     Net::HTTP.get(_uri)
  #
  # ### Fragments
  #
  # A [URI fragment](https://en.wikipedia.org/wiki/URI_fragment) has no effect in
  # Net::HTTP; the same data is returned, regardless of whether a fragment is
  # included.
  #
  # ## Request Headers
  #
  # Request headers may be used to pass additional information to the host,
  # similar to arguments passed in a method call; each header is a name/value
  # pair.
  #
  # Each of the Net::HTTP methods that sends a request to the host has optional
  # argument `headers`, where the headers are expressed as a hash of
  # field-name/value pairs:
  #
  #     headers = {Accept: 'application/json', Connection: 'Keep-Alive'}
  #     Net::HTTP.get(uri, headers)
  #
  # See lists of both standard request fields and common request fields at
  # [Request
  # Fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_field
  # s). A host may also accept other custom fields.
  #
  # ## HTTP Sessions
  #
  # A *session* is a connection between a server (host) and a client that:
  #
  # *   Is begun by instance method Net::HTTP#start.
  # *   May contain any number of requests.
  # *   Is ended by instance method Net::HTTP#finish.
  #
  #
  # See example sessions at [Strategies](rdoc-ref:Net::HTTP@Strategies).
  #
  # ### Session Using Net::HTTP.start
  #
  # If you have many requests to make to a single host (and port), consider using
  # singleton method Net::HTTP.start with a block; the method handles the session
  # automatically by:
  #
  # *   Calling #start before block execution.
  # *   Executing the block.
  # *   Calling #finish after block execution.
  #
  #
  # In the block, you can use these instance methods, each of which that sends a
  # single request:
  #
  # *   [HTTP
  #     methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request
  #     _methods):
  #
  #     *   #get, #request_get: GET.
  #     *   #head, #request_head: HEAD.
  #     *   #post, #request_post: POST.
  #     *   #delete: DELETE.
  #     *   #options: OPTIONS.
  #     *   #trace: TRACE.
  #     *   #patch: PATCH.
  #
  #
  # *   [WebDAV methods](https://en.wikipedia.org/wiki/WebDAV#Implementation):
  #
  #     *   #copy: COPY.
  #     *   #lock: LOCK.
  #     *   #mkcol: MKCOL.
  #     *   #move: MOVE.
  #     *   #propfind: PROPFIND.
  #     *   #proppatch: PROPPATCH.
  #     *   #unlock: UNLOCK.
  #
  #
  #
  # ### Session Using Net::HTTP.start and Net::HTTP.finish
  #
  # You can manage a session manually using methods #start and #finish:
  #
  #     http = Net::HTTP.new(hostname)
  #     http.start
  #     http.get('/todos/1')
  #     http.get('/todos/2')
  #     http.delete('/posts/1')
  #     http.finish # Needed to free resources.
  #
  # ### Single-Request Session
  #
  # Certain convenience methods automatically handle a session by:
  #
  # *   Creating an HTTP object
  # *   Starting a session.
  # *   Sending a single request.
  # *   Finishing the session.
  # *   Destroying the object.
  #
  #
  # Such methods that send GET requests:
  #
  # *   ::get: Returns the string response body.
  # *   ::get_print: Writes the string response body to $stdout.
  # *   ::get_response: Returns a Net::HTTPResponse object.
  #
  #
  # Such methods that send POST requests:
  #
  # *   ::post: Posts data to the host.
  # *   ::post_form: Posts form data to the host.
  #
  #
  # ## HTTP Requests and Responses
  #
  # Many of the methods above are convenience methods, each of which sends a
  # request and returns a string without directly using Net::HTTPRequest and
  # Net::HTTPResponse objects.
  #
  # You can, however, directly create a request object, send the request, and
  # retrieve the response object; see:
  #
  # *   Net::HTTPRequest.
  # *   Net::HTTPResponse.
  #
  #
  # ## Following Redirection
  #
  # Each returned response is an instance of a subclass of Net::HTTPResponse. See
  # the [response class
  # hierarchy](rdoc-ref:Net::HTTPResponse@Response+Subclasses).
  #
  # In particular, class Net::HTTPRedirection is the parent of all redirection
  # classes. This allows you to craft a case statement to handle redirections
  # properly:
  #
  #     def fetch(uri, limit = 10)
  #       # You should choose a better exception.
  #       raise ArgumentError, 'Too many HTTP redirects' if limit == 0
  #
  #       res = Net::HTTP.get_response(URI(uri))
  #       case res
  #       when Net::HTTPSuccess     # Any success class.
  #         res
  #       when Net::HTTPRedirection # Any redirection class.
  #         location = res['Location']
  #         warn "Redirected to #{location}"
  #         fetch(location, limit - 1)
  #       else                      # Any other class.
  #         res.value
  #       end
  #     end
  #
  #     fetch(uri)
  #
  # ## Basic Authentication
  #
  # Basic authentication is performed according to
  # [RFC2617](http://www.ietf.org/rfc/rfc2617.txt):
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req.basic_auth('user', 'pass')
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # ## Streaming Response Bodies
  #
  # By default Net::HTTP reads an entire response into memory.  If you are
  # handling large files or wish to implement a progress bar you can instead
  # stream the body directly to an IO.
  #
  #     Net::HTTP.start(hostname) do |http|
  #       req = Net::HTTP::Get.new(uri)
  #       http.request(req) do |res|
  #         open('t.tmp', 'w') do |f|
  #           res.read_body do |chunk|
  #             f.write chunk
  #           end
  #         end
  #       end
  #     end
  #
  # ## HTTPS
  #
  # HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=:
  #
  #     Net::HTTP.start(hostname, :use_ssl => true) do |http|
  #       req = Net::HTTP::Get.new(uri)
  #       res = http.request(req)
  #     end
  #
  # Or if you simply want to make a GET request, you may pass in a URI object that
  # has an HTTPS URL. Net::HTTP automatically turns on TLS verification if the URI
  # object has a 'https' URI scheme:
  #
  #     uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
  #     Net::HTTP.get(uri)
  #
  # ## Proxy Server
  #
  # An HTTP object can have a [proxy
  # server](https://en.wikipedia.org/wiki/Proxy_server).
  #
  # You can create an HTTP object with a proxy server using method Net::HTTP.new
  # or method Net::HTTP.start.
  #
  # The proxy may be defined either by argument `p_addr` or by environment
  # variable `'http_proxy'`.
  #
  # ### Proxy Using Argument `p_addr` as a String
  #
  # When argument `p_addr` is a string hostname, the returned `http` has the given
  # host as its proxy:
  #
  #     http = Net::HTTP.new(hostname, nil, 'proxy.example')
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => false
  #     http.proxy_address   # => "proxy.example"
  #     # These use default values.
  #     http.proxy_port      # => 80
  #     http.proxy_user      # => nil
  #     http.proxy_pass      # => nil
  #
  # The port, username, and password for the proxy may also be given:
  #
  #     http = Net::HTTP.new(hostname, nil, 'proxy.example', 8000, 'pname', 'ppass')
  #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => false
  #     http.proxy_address   # => "proxy.example"
  #     http.proxy_port      # => 8000
  #     http.proxy_user      # => "pname"
  #     http.proxy_pass      # => "ppass"
  #
  # ### Proxy Using '`ENV['http_proxy']`'
  #
  # When environment variable `'http_proxy'` is set to a URI string, the returned
  # `http` will have the server at that URI as its proxy; note that the URI string
  # must have a protocol such as `'http'` or `'https'`:
  #
  #     ENV['http_proxy'] = 'http://example.com'
  #     http = Net::HTTP.new(hostname)
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => true
  #     http.proxy_address   # => "example.com"
  #     # These use default values.
  #     http.proxy_port      # => 80
  #     http.proxy_user      # => nil
  #     http.proxy_pass      # => nil
  #
  # The URI string may include proxy username, password, and port number:
  #
  #     ENV['http_proxy'] = 'http://pname:ppass@example.com:8000'
  #     http = Net::HTTP.new(hostname)
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => true
  #     http.proxy_address   # => "example.com"
  #     http.proxy_port      # => 8000
  #     http.proxy_user      # => "pname"
  #     http.proxy_pass      # => "ppass"
  #
  # ### Filtering Proxies
  #
  # With method Net::HTTP.new (but not Net::HTTP.start), you can use argument
  # `p_no_proxy` to filter proxies:
  #
  # *   Reject a certain address:
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
  #         http.proxy_address # => nil
  #
  # *   Reject certain domains or subdomains:
  #
  #         http = Net::HTTP.new('example.com', nil, 'my.proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
  #         http.proxy_address # => nil
  #
  # *   Reject certain addresses and port combinations:
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:1234')
  #         http.proxy_address # => "proxy.example"
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:8000')
  #         http.proxy_address # => nil
  #
  # *   Reject a list of the types above delimited using a comma:
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
  #         http.proxy_address # => nil
  #
  #         http = Net::HTTP.new('example.com', nil, 'my.proxy', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
  #         http.proxy_address # => nil
  #
  #
  # ## Compression and Decompression
  #
  # Net::HTTP does not compress the body of a request before sending.
  #
  # By default, Net::HTTP adds header `'Accept-Encoding'` to a new [request
  # object](rdoc-ref:Net::HTTPRequest):
  #
  #     Net::HTTP::Get.new(uri)['Accept-Encoding']
  #     # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
  #
  # This requests the server to zip-encode the response body if there is one; the
  # server is not required to do so.
  #
  # Net::HTTP does not automatically decompress a response body if the response
  # has header `'Content-Range'`.
  #
  # Otherwise decompression (or not) depends on the value of header
  # [Content-Encoding](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#co
  # ntent-encoding-response-header):
  #
  # *   `'deflate'`, `'gzip'`, or `'x-gzip'`: decompresses the body and deletes
  #     the header.
  # *   `'none'` or `'identity'`: does not decompress the body, but deletes the
  #     header.
  # *   Any other value: leaves the body and header unchanged.
  #
  #
  # ## What's Here
  #
  # This is a categorized summary of methods and attributes.
  #
  # ### Net::HTTP Objects
  #
  # *   [::new](rdoc-ref:Net::HTTP.new): Creates a new instance.
  # *   [#inspect](rdoc-ref:Net::HTTP#inspect): Returns a string representation of
  #     `self`.
  #
  #
  # ### Sessions
  #
  # *   [::start](rdoc-ref:Net::HTTP.start): Begins a new session in a new
  #     Net::HTTP object.
  # *   [#started?](rdoc-ref:Net::HTTP#started?) (aliased as
  #     [#active?](rdoc-ref:Net::HTTP#active?)): Returns whether in a session.
  # *   [#finish](rdoc-ref:Net::HTTP#finish): Ends an active session.
  # *   [#start](rdoc-ref:Net::HTTP#start): Begins a new session in an existing
  #     Net::HTTP object (`self`).
  #
  #
  # ### Connections
  #
  # *   [:continue_timeout](rdoc-ref:Net::HTTP#continue_timeout): Returns the
  #     continue timeout.
  # *   [#continue_timeout=](rdoc-ref:Net::HTTP#continue_timeout=): Sets the
  #     continue timeout seconds.
  # *   [:keep_alive_timeout](rdoc-ref:Net::HTTP#keep_alive_timeout): Returns the
  #     keep-alive timeout.
  # *   [:keep_alive_timeout=](rdoc-ref:Net::HTTP#keep_alive_timeout=): Sets the
  #     keep-alive timeout.
  # *   [:max_retries](rdoc-ref:Net::HTTP#max_retries): Returns the maximum
  #     retries.
  # *   [#max_retries=](rdoc-ref:Net::HTTP#max_retries=): Sets the maximum
  #     retries.
  # *   [:open_timeout](rdoc-ref:Net::HTTP#open_timeout): Returns the open
  #     timeout.
  # *   [:open_timeout=](rdoc-ref:Net::HTTP#open_timeout=): Sets the open timeout.
  # *   [:read_timeout](rdoc-ref:Net::HTTP#read_timeout): Returns the open
  #     timeout.
  # *   [:read_timeout=](rdoc-ref:Net::HTTP#read_timeout=): Sets the read timeout.
  # *   [:ssl_timeout](rdoc-ref:Net::HTTP#ssl_timeout): Returns the ssl timeout.
  # *   [:ssl_timeout=](rdoc-ref:Net::HTTP#ssl_timeout=): Sets the ssl timeout.
  # *   [:write_timeout](rdoc-ref:Net::HTTP#write_timeout): Returns the write
  #     timeout.
  # *   [write_timeout=](rdoc-ref:Net::HTTP#write_timeout=): Sets the write
  #     timeout.
  #
  #
  # ### Requests
  #
  # *   [::get](rdoc-ref:Net::HTTP.get): Sends a GET request and returns the
  #     string response body.
  # *   [::get_print](rdoc-ref:Net::HTTP.get_print): Sends a GET request and write
  #     the string response body to $stdout.
  # *   [::get_response](rdoc-ref:Net::HTTP.get_response): Sends a GET request and
  #     returns a response object.
  # *   [::post_form](rdoc-ref:Net::HTTP.post_form): Sends a POST request with
  #     form data and returns a response object.
  # *   [::post](rdoc-ref:Net::HTTP.post): Sends a POST request with data and
  #     returns a response object.
  # *   [#copy](rdoc-ref:Net::HTTP#copy): Sends a COPY request and returns a
  #     response object.
  # *   [#delete](rdoc-ref:Net::HTTP#delete): Sends a DELETE request and returns a
  #     response object.
  # *   [#get](rdoc-ref:Net::HTTP#get): Sends a GET request and returns a response
  #     object.
  # *   [#head](rdoc-ref:Net::HTTP#head): Sends a HEAD request and returns a
  #     response object.
  # *   [#lock](rdoc-ref:Net::HTTP#lock): Sends a LOCK request and returns a
  #     response object.
  # *   [#mkcol](rdoc-ref:Net::HTTP#mkcol): Sends a MKCOL request and returns a
  #     response object.
  # *   [#move](rdoc-ref:Net::HTTP#move): Sends a MOVE request and returns a
  #     response object.
  # *   [#options](rdoc-ref:Net::HTTP#options): Sends a OPTIONS request and
  #     returns a response object.
  # *   [#patch](rdoc-ref:Net::HTTP#patch): Sends a PATCH request and returns a
  #     response object.
  # *   [#post](rdoc-ref:Net::HTTP#post): Sends a POST request and returns a
  #     response object.
  # *   [#propfind](rdoc-ref:Net::HTTP#propfind): Sends a PROPFIND request and
  #     returns a response object.
  # *   [#proppatch](rdoc-ref:Net::HTTP#proppatch): Sends a PROPPATCH request and
  #     returns a response object.
  # *   [#put](rdoc-ref:Net::HTTP#put): Sends a PUT request and returns a response
  #     object.
  # *   [#request](rdoc-ref:Net::HTTP#request): Sends a request and returns a
  #     response object.
  # *   [#request_get](rdoc-ref:Net::HTTP#request_get) (aliased as
  #     [#get2](rdoc-ref:Net::HTTP#get2)): Sends a GET request and forms a
  #     response object; if a block given, calls the block with the object,
  #     otherwise returns the object.
  # *   [#request_head](rdoc-ref:Net::HTTP#request_head) (aliased as
  #     [#head2](rdoc-ref:Net::HTTP#head2)): Sends a HEAD request and forms a
  #     response object; if a block given, calls the block with the object,
  #     otherwise returns the object.
  # *   [#request_post](rdoc-ref:Net::HTTP#request_post) (aliased as
  #     [#post2](rdoc-ref:Net::HTTP#post2)): Sends a POST request and forms a
  #     response object; if a block given, calls the block with the object,
  #     otherwise returns the object.
  # *   [#send_request](rdoc-ref:Net::HTTP#send_request): Sends a request and
  #     returns a response object.
  # *   [#trace](rdoc-ref:Net::HTTP#trace): Sends a TRACE request and returns a
  #     response object.
  # *   [#unlock](rdoc-ref:Net::HTTP#unlock): Sends an UNLOCK request and returns
  #     a response object.
  #
  #
  # ### Responses
  #
  # *   [:close_on_empty_response](rdoc-ref:Net::HTTP#close_on_empty_response):
  #     Returns whether to close connection on empty response.
  # *   [:close_on_empty_response=](rdoc-ref:Net::HTTP#close_on_empty_response=):
  #     Sets whether to close connection on empty response.
  # *   [:ignore_eof](rdoc-ref:Net::HTTP#ignore_eof): Returns whether to ignore
  #     end-of-file when reading a response body with `Content-Length` headers.
  # *   [:ignore_eof=](rdoc-ref:Net::HTTP#ignore_eof=): Sets whether to ignore
  #     end-of-file when reading a response body with `Content-Length` headers.
  # *   [:response_body_encoding](rdoc-ref:Net::HTTP#response_body_encoding):
  #     Returns the encoding to use for the response body.
  # *   [#response_body_encoding=](rdoc-ref:Net::HTTP#response_body_encoding=):
  #     Sets the response body encoding.
  #
  #
  # ### Proxies
  #
  # *   [:proxy_address](rdoc-ref:Net::HTTP#proxy_address): Returns the proxy
  #     address.
  # *   [:proxy_address=](rdoc-ref:Net::HTTP#proxy_address=): Sets the proxy
  #     address.
  # *   [::proxy_class?](rdoc-ref:Net::HTTP.proxy_class?): Returns whether `self`
  #     is a proxy class.
  # *   [#proxy?](rdoc-ref:Net::HTTP#proxy?): Returns whether `self` has a proxy.
  # *   [#proxy_address](rdoc-ref:Net::HTTP#proxy_address) (aliased as
  #     [#proxyaddr](rdoc-ref:Net::HTTP#proxyaddr)): Returns the proxy address.
  # *   [#proxy_from_env?](rdoc-ref:Net::HTTP#proxy_from_env?): Returns whether
  #     the proxy is taken from an environment variable.
  # *   [:proxy_from_env=](rdoc-ref:Net::HTTP#proxy_from_env=): Sets whether the
  #     proxy is to be taken from an environment variable.
  # *   [:proxy_pass](rdoc-ref:Net::HTTP#proxy_pass): Returns the proxy password.
  # *   [:proxy_pass=](rdoc-ref:Net::HTTP#proxy_pass=): Sets the proxy password.
  # *   [:proxy_port](rdoc-ref:Net::HTTP#proxy_port): Returns the proxy port.
  # *   [:proxy_port=](rdoc-ref:Net::HTTP#proxy_port=): Sets the proxy port.
  # *   [#proxy_user](rdoc-ref:Net::HTTP#proxy_user): Returns the proxy user name.
  # *   [:proxy_user=](rdoc-ref:Net::HTTP#proxy_user=): Sets the proxy user.
  #
  #
  # ### Security
  #
  # *   [:ca_file](rdoc-ref:Net::HTTP#ca_file): Returns the path to a CA
  #     certification file.
  # *   [:ca_file=](rdoc-ref:Net::HTTP#ca_file=): Sets the path to a CA
  #     certification file.
  # *   [:ca_path](rdoc-ref:Net::HTTP#ca_path): Returns the path of to CA
  #     directory containing certification files.
  # *   [:ca_path=](rdoc-ref:Net::HTTP#ca_path=): Sets the path of to CA directory
  #     containing certification files.
  # *   [:cert](rdoc-ref:Net::HTTP#cert): Returns the OpenSSL::X509::Certificate
  #     object to be used for client certification.
  # *   [:cert=](rdoc-ref:Net::HTTP#cert=): Sets the OpenSSL::X509::Certificate
  #     object to be used for client certification.
  # *   [:cert_store](rdoc-ref:Net::HTTP#cert_store): Returns the X509::Store to
  #     be used for verifying peer certificate.
  # *   [:cert_store=](rdoc-ref:Net::HTTP#cert_store=): Sets the X509::Store to be
  #     used for verifying peer certificate.
  # *   [:ciphers](rdoc-ref:Net::HTTP#ciphers): Returns the available SSL ciphers.
  # *   [:ciphers=](rdoc-ref:Net::HTTP#ciphers=): Sets the available SSL ciphers.
  # *   [:extra_chain_cert](rdoc-ref:Net::HTTP#extra_chain_cert): Returns the
  #     extra X509 certificates to be added to the certificate chain.
  # *   [:extra_chain_cert=](rdoc-ref:Net::HTTP#extra_chain_cert=): Sets the extra
  #     X509 certificates to be added to the certificate chain.
  # *   [:key](rdoc-ref:Net::HTTP#key): Returns the OpenSSL::PKey::RSA or
  #     OpenSSL::PKey::DSA object.
  # *   [:key=](rdoc-ref:Net::HTTP#key=): Sets the OpenSSL::PKey::RSA or
  #     OpenSSL::PKey::DSA object.
  # *   [:max_version](rdoc-ref:Net::HTTP#max_version): Returns the maximum SSL
  #     version.
  # *   [:max_version=](rdoc-ref:Net::HTTP#max_version=): Sets the maximum SSL
  #     version.
  # *   [:min_version](rdoc-ref:Net::HTTP#min_version): Returns the minimum SSL
  #     version.
  # *   [:min_version=](rdoc-ref:Net::HTTP#min_version=): Sets the minimum SSL
  #     version.
  # *   [#peer_cert](rdoc-ref:Net::HTTP#peer_cert): Returns the X509 certificate
  #     chain for the session's socket peer.
  # *   [:ssl_version](rdoc-ref:Net::HTTP#ssl_version): Returns the SSL version.
  # *   [:ssl_version=](rdoc-ref:Net::HTTP#ssl_version=): Sets the SSL version.
  # *   [#use_ssl=](rdoc-ref:Net::HTTP#use_ssl=): Sets whether a new session is to
  #     use Transport Layer Security.
  # *   [#use_ssl?](rdoc-ref:Net::HTTP#use_ssl?): Returns whether `self` uses SSL.
  # *   [:verify_callback](rdoc-ref:Net::HTTP#verify_callback): Returns the
  #     callback for the server certification verification.
  # *   [:verify_callback=](rdoc-ref:Net::HTTP#verify_callback=): Sets the
  #     callback for the server certification verification.
  # *   [:verify_depth](rdoc-ref:Net::HTTP#verify_depth): Returns the maximum
  #     depth for the certificate chain verification.
  # *   [:verify_depth=](rdoc-ref:Net::HTTP#verify_depth=): Sets the maximum depth
  #     for the certificate chain verification.
  # *   [:verify_hostname](rdoc-ref:Net::HTTP#verify_hostname): Returns the flags
  #     for server the certification verification at the beginning of the SSL/TLS
  #     session.
  # *   [:verify_hostname=](rdoc-ref:Net::HTTP#verify_hostname=): Sets he flags
  #     for server the certification verification at the beginning of the SSL/TLS
  #     session.
  # *   [:verify_mode](rdoc-ref:Net::HTTP#verify_mode): Returns the flags for
  #     server the certification verification at the beginning of the SSL/TLS
  #     session.
  # *   [:verify_mode=](rdoc-ref:Net::HTTP#verify_mode=): Sets the flags for
  #     server the certification verification at the beginning of the SSL/TLS
  #     session.
  #
  #
  # ### Addresses and Ports
  #
  # *   [:address](rdoc-ref:Net::HTTP#address): Returns the string host name or
  #     host IP.
  # *   [::default_port](rdoc-ref:Net::HTTP.default_port): Returns integer 80, the
  #     default port to use for HTTP requests.
  # *   [::http_default_port](rdoc-ref:Net::HTTP.http_default_port): Returns
  #     integer 80, the default port to use for HTTP requests.
  # *   [::https_default_port](rdoc-ref:Net::HTTP.https_default_port): Returns
  #     integer 443, the default port to use for HTTPS requests.
  # *   [#ipaddr](rdoc-ref:Net::HTTP#ipaddr): Returns the IP address for the
  #     connection.
  # *   [#ipaddr=](rdoc-ref:Net::HTTP#ipaddr=): Sets the IP address for the
  #     connection.
  # *   [:local_host](rdoc-ref:Net::HTTP#local_host): Returns the string local
  #     host used to establish the connection.
  # *   [:local_host=](rdoc-ref:Net::HTTP#local_host=): Sets the string local host
  #     used to establish the connection.
  # *   [:local_port](rdoc-ref:Net::HTTP#local_port): Returns the integer local
  #     port used to establish the connection.
  # *   [:local_port=](rdoc-ref:Net::HTTP#local_port=): Sets the integer local
  #     port used to establish the connection.
  # *   [:port](rdoc-ref:Net::HTTP#port): Returns the integer port number.
  #
  #
  # ### HTTP Version
  #
  # *   [::version_1_2?](rdoc-ref:Net::HTTP.version_1_2?) (aliased as
  #     [::is_version_1_2?](rdoc-ref:Net::HTTP.is_version_1_2?) and
  #     [::version_1_2](rdoc-ref:Net::HTTP.version_1_2)): Returns true; retained
  #     for compatibility.
  #
  #
  # ### Debugging
  #
  # *   [#set_debug_output](rdoc-ref:Net::HTTP#set_debug_output): Sets the output
  #     stream for debugging.
  #
  class HTTP < Protocol
    # :stopdoc:
    VERSION: String

    Revision: untyped

    HTTPVersion: String

    HAVE_ZLIB: bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2()
    # -->
    # Returns `true`; retained for compatibility.
    #
    def self.version_1_2: () -> ::TrueClass

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2?()
    # -->
    # Returns `true`; retained for compatibility.
    #
    def self.version_1_2?: () -> ::TrueClass

    def self.version_1_1?: () -> ::FalseClass

    alias self.is_version_1_1? self.version_1_1?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - is_version_1_2?()
    # -->
    #
    alias self.is_version_1_2? self.version_1_2?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get_print(hostname, path, port = 80) -> nil
    #   - Net::HTTP:get_print(uri, headers = {}, port = uri.port) -> nil
    # -->
    # Like Net::HTTP.get, but writes the returned body to $stdout; returns `nil`.
    #
    def self.get_print: (URI::Generic uri, ?Hash[String, untyped] header) -> void
                      | (String host, String path, ?Integer port) -> void

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get(hostname, path, port = 80) -> body
    #   - Net::HTTP:get(uri, headers = {}, port = uri.port) -> body
    # -->
    # Sends a GET request and returns the HTTP response body as a string.
    #
    # With string arguments `hostname` and `path`:
    #
    #     hostname = 'jsonplaceholder.typicode.com'
    #     path = '/todos/1'
    #     puts Net::HTTP.get(hostname, path)
    #
    # Output:
    #
    #     {
    #       "userId": 1,
    #       "id": 1,
    #       "title": "delectus aut autem",
    #       "completed": false
    #     }
    #
    # With URI object `uri` and optional hash argument `headers`:
    #
    #     uri = URI('https://jsonplaceholder.typicode.com/todos/1')
    #     headers = {'Content-type' => 'application/json; charset=UTF-8'}
    #     Net::HTTP.get(uri, headers)
    #
    # Related:
    #
    # *   Net::HTTP::Get: request class for HTTP method `GET`.
    # *   Net::HTTP#get: convenience method for HTTP method `GET`.
    #
    def self.get: (URI::Generic uri, ?Hash[String, untyped] header) -> String
                | (String host, String path, ?Integer port) -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get_response(hostname, path, port = 80) -> http_response
    #   - Net::HTTP:get_response(uri, headers = {}, port = uri.port) -> http_response
    # -->
    # Like Net::HTTP.get, but returns a Net::HTTPResponse object instead of the body
    # string.
    #
    def self.get_response: (URI::Generic uri, ?Hash[String, untyped] header) ?{ (Net::HTTPResponse) -> void } -> Net::HTTPResponse
                         | (String host, String path, ?Integer port) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(url, data, header = nil)
    # -->
    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument `url` must be a URL; argument `data` must be a string:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     data = '{"title": "foo", "body": "bar", "userId": 1}'
    #     headers = {'content-type': 'application/json'}
    #     res = Net::HTTP.post(_uri, data, headers) # => #<Net::HTTPCreated 201 Created readbody=true>
    #     puts res.body
    #
    # Output:
    #
    #     {
    #       "title": "foo",
    #       "body": "bar",
    #       "userId": 1,
    #       "id": 101
    #     }
    #
    # Related:
    #
    # *   Net::HTTP::Post: request class for HTTP method `POST`.
    # *   Net::HTTP#post: convenience method for HTTP method `POST`.
    #
    def self.post: (URI::Generic url, String data, ?Hash[String, untyped] header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post_form(url, params)
    # -->
    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument `url` must be a URI; argument `data` must be a hash:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     data = {title: 'foo', body: 'bar', userId: 1}
    #     res = Net::HTTP.post_form(_uri, data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #     puts res.body
    #
    # Output:
    #
    #     {
    #       "title": "foo",
    #       "body": "bar",
    #       "userId": "1",
    #       "id": 101
    #     }
    #
    def self.post_form: (URI::Generic url, Hash[String, untyped] params) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - default_port()
    # -->
    # Returns integer `80`, the default port to use for HTTP requests:
    #
    #     Net::HTTP.default_port # => 80
    #
    def self.default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - http_default_port()
    # -->
    # Returns integer `80`, the default port to use for HTTP requests:
    #
    #     Net::HTTP.http_default_port # => 80
    #
    def self.http_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - https_default_port()
    # -->
    # Returns integer `443`, the default port to use for HTTPS requests:
    #
    #     Net::HTTP.https_default_port # => 443
    #
    def self.https_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) -> http
    #   - HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) {|http| ... } -> object
    # -->
    # Creates a new Net::HTTP object, `http`, via Net::HTTP.new:
    #
    # *   For arguments `address` and `port`, see Net::HTTP.new.
    # *   For proxy-defining arguments `p_addr` through `p_pass`, see [Proxy
    #     Server](rdoc-ref:Net::HTTP@Proxy+Server).
    # *   For argument `opts`, see below.
    #
    #
    # With no block given:
    #
    # *   Calls `http.start` with no block (see #start), which opens a TCP
    #     connection and HTTP session.
    # *   Returns `http`.
    # *   The caller should call #finish to close the session:
    #
    #         http = Net::HTTP.start(hostname)
    #         http.started? # => true
    #         http.finish
    #         http.started? # => false
    #
    #
    # With a block given:
    #
    # *   Calls `http.start` with the block (see #start), which:
    #
    #     *   Opens a TCP connection and HTTP session.
    #     *   Calls the block, which may make any number of requests to the host.
    #     *   Closes the HTTP session and TCP connection on block exit.
    #     *   Returns the block's value `object`.
    #
    #
    # *   Returns `object`.
    #
    #
    # Example:
    #
    #     hostname = 'jsonplaceholder.typicode.com'
    #     Net::HTTP.start(hostname) do |http|
    #       puts http.get('/todos/1').body
    #       puts http.get('/todos/2').body
    #     end
    #
    # Output:
    #
    #     {
    #       "userId": 1,
    #       "id": 1,
    #       "title": "delectus aut autem",
    #       "completed": false
    #     }
    #     {
    #       "userId": 1,
    #       "id": 2,
    #       "title": "quis ut nam facilis et officia qui",
    #       "completed": false
    #     }
    #
    # If the last argument given is a hash, it is the `opts` hash, where each key is
    # a method or accessor to be called, and its value is the value to be set.
    #
    # The keys may include:
    #
    # *   #ca_file
    # *   #ca_path
    # *   #cert
    # *   #cert_store
    # *   #ciphers
    # *   #close_on_empty_response
    # *   `ipaddr` (calls #ipaddr=)
    # *   #keep_alive_timeout
    # *   #key
    # *   #open_timeout
    # *   #read_timeout
    # *   #ssl_timeout
    # *   #ssl_version
    # *   `use_ssl` (calls #use_ssl=)
    # *   #verify_callback
    # *   #verify_depth
    # *   #verify_mode
    # *   #write_timeout
    #
    #
    # Note: If `port` is `nil` and `opts[:use_ssl]` is a truthy value, the value
    # passed to `new` is Net::HTTP.https_default_port, not `port`.
    #
    def self.start: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) -> Net::HTTP
                  | [T] (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) { (Net::HTTP) -> T } -> T

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - newobj(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)
    # -->
    #
    alias self.newobj self.new

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - new(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)
    # -->
    # Returns a new Net::HTTP object `http` (but does not open a TCP connection or
    # HTTP session).
    #
    # With only string argument `address` given (and `ENV['http_proxy']` undefined
    # or `nil`), the returned `http`:
    #
    # *   Has the given address.
    # *   Has the default port number, Net::HTTP.default_port (80).
    # *   Has no proxy.
    #
    #
    # Example:
    #
    #     http = Net::HTTP.new(hostname)
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #     http.address # => "jsonplaceholder.typicode.com"
    #     http.port    # => 80
    #     http.proxy?  # => false
    #
    # With integer argument `port` also given, the returned `http` has the given
    # port:
    #
    #     http = Net::HTTP.new(hostname, 8000)
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:8000 open=false>
    #     http.port # => 8000
    #
    # For proxy-defining arguments `p_addr` through `p_no_proxy`, see [Proxy
    # Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    def self.new: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?untyped? p_no_proxy) -> Net::HTTP

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - inspect()
    # -->
    # Returns a string representation of `self`:
    #
    #     Net::HTTP.new(hostname).inspect
    #     # => "#<Net::HTTP jsonplaceholder.typicode.com:80 open=false>"
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - set_debug_output(output)
    # -->
    # **WARNING** This method opens a serious security hole. Never use this method
    # in production code.
    #
    # Sets the output stream for debugging:
    #
    #     http = Net::HTTP.new(hostname)
    #     File.open('t.tmp', 'w') do |file|
    #       http.set_debug_output(file)
    #       http.start
    #       http.get('/nosuch/1')
    #       http.finish
    #     end
    #     puts File.read('t.tmp')
    #
    # Output:
    #
    #     opening connection to jsonplaceholder.typicode.com:80...
    #     opened
    #     <- "GET /nosuch/1 HTTP/1.1\r\nAccept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3\r\nAccept: */*\r\nUser-Agent: Ruby\r\nHost: jsonplaceholder.typicode.com\r\n\r\n"
    #     -> "HTTP/1.1 404 Not Found\r\n"
    #     -> "Date: Mon, 12 Dec 2022 21:14:11 GMT\r\n"
    #     -> "Content-Type: application/json; charset=utf-8\r\n"
    #     -> "Content-Length: 2\r\n"
    #     -> "Connection: keep-alive\r\n"
    #     -> "X-Powered-By: Express\r\n"
    #     -> "X-Ratelimit-Limit: 1000\r\n"
    #     -> "X-Ratelimit-Remaining: 999\r\n"
    #     -> "X-Ratelimit-Reset: 1670879660\r\n"
    #     -> "Vary: Origin, Accept-Encoding\r\n"
    #     -> "Access-Control-Allow-Credentials: true\r\n"
    #     -> "Cache-Control: max-age=43200\r\n"
    #     -> "Pragma: no-cache\r\n"
    #     -> "Expires: -1\r\n"
    #     -> "X-Content-Type-Options: nosniff\r\n"
    #     -> "Etag: W/\"2-vyGp6PvFo4RvsFtPoIWeCReyIC8\"\r\n"
    #     -> "Via: 1.1 vegur\r\n"
    #     -> "CF-Cache-Status: MISS\r\n"
    #     -> "Server-Timing: cf-q-config;dur=1.3000000762986e-05\r\n"
    #     -> "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yOr40jo%2BwS1KHzhTlVpl54beJ5Wx2FcG4gGV0XVrh3X9OlR5q4drUn2dkt5DGO4GDcE%2BVXT7CNgJvGs%2BZleIyMu8CLieFiDIvOviOY3EhHg94m0ZNZgrEdpKD0S85S507l1vsEwEHkoTm%2Ff19SiO\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\n"
    #     -> "NEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\n"
    #     -> "Server: cloudflare\r\n"
    #     -> "CF-RAY: 778977dc484ce591-DFW\r\n"
    #     -> "alt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n"
    #     -> "\r\n"
    #     reading 2 bytes...
    #     -> "{}"
    #     read 2 bytes
    #     Conn keep-alive
    #
    def set_debug_output: (IO output) -> void

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the string host name or host IP given as argument `address` in ::new.
    #
    attr_reader address: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the integer port number given as argument `port` in ::new.
    #
    attr_reader port: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the string local host used to establish the connection;
    # initially `nil`.
    #
    attr_accessor local_host: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the integer local port used to establish the connection;
    # initially `nil`.
    #
    attr_accessor local_port: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets whether to determine the proxy from environment variable
    # '`ENV['http_proxy']`'; see [Proxy Using
    # ENV['http_proxy']](rdoc-ref:Net::HTTP@Proxy+Using+-27ENV-5B-27http_proxy-27-5D
    # -27).
    #
    attr_writer proxy_from_env: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy address; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy port; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy user; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy password; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr()
    # -->
    # Returns the IP address for the connection.
    #
    # If the session has not been started, returns the value set by #ipaddr=, or
    # `nil` if it has not been set:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.ipaddr # => nil
    #     http.ipaddr = '172.67.155.76'
    #     http.ipaddr # => "172.67.155.76"
    #
    # If the session has been started, returns the IP address from the socket:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.start
    #     http.ipaddr # => "172.67.155.76"
    #     http.finish
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr=(addr)
    # -->
    # Sets the IP address for the connection:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.ipaddr # => nil
    #     http.ipaddr = '172.67.155.76'
    #     http.ipaddr # => "172.67.155.76"
    #
    # The IP address may not be set if the session has been started.
    #
    attr_accessor ipaddr: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the numeric (Integer or Float) number of seconds to wait for a
    # connection to open; initially 60. If the connection is not made in the given
    # interval, an exception is raised.
    #
    attr_accessor open_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the numeric (Integer or Float) number of seconds to wait for one block
    # to be read (via one read(2) call); see #read_timeout=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - read_timeout=(sec)
    # -->
    # Sets the read timeout, in seconds, for `self` to integer `sec`; the initial
    # value is 60.
    #
    # Argument `sec` must be a non-negative numeric value:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.read_timeout # => 60
    #     http.get('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #     http.read_timeout = 0
    #     http.get('/todos/1') # Raises Net::ReadTimeout.
    #
    attr_accessor read_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the numeric (Integer or Float) number of seconds to wait for one block
    # to be written (via one write(2) call); see #write_timeout=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - write_timeout=(sec)
    # -->
    # Sets the write timeout, in seconds, for `self` to integer `sec`; the initial
    # value is 60.
    #
    # Argument `sec` must be a non-negative numeric value:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     body = 'bar' * 200000
    #     data = <<EOF
    #     {"title": "foo", "body": "#{body}", "userId": "1"}
    #     EOF
    #     headers = {'content-type': 'application/json'}
    #     http = Net::HTTP.new(hostname)
    #     http.write_timeout # => 60
    #     http.post(_uri.path, data, headers)
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #     http.write_timeout = 0
    #     http.post(_uri.path, data, headers) # Raises Net::WriteTimeout.
    #
    attr_accessor write_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the maximum number of times to retry an idempotent request; see
    # #max_retries=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - max_retries=(retries)
    # -->
    # Sets the maximum number of times to retry an idempotent request in case of
    # Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET, Errno::ECONNABORTED,
    # Errno::EPIPE, OpenSSL::SSL::SSLError, Timeout::Error. The initial value is 1.
    #
    # Argument `retries` must be a non-negative numeric value:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.max_retries = 2   # => 2
    #     http.max_retries       # => 2
    #
    attr_accessor max_retries: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the continue timeout value; see continue_timeout=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - continue_timeout=(sec)
    # -->
    # Sets the continue timeout value, which is the number of seconds to wait for an
    # expected 100 Continue response. If the HTTP object does not receive a response
    # in this many seconds it sends the request body.
    #
    attr_accessor continue_timeout: Float | Integer | nil

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the numeric (Integer or Float) number of seconds to keep the
    # connection open after a request is sent; initially 2. If a new request is made
    # during the given interval, the still-open connection is used; otherwise the
    # connection will have been closed and a new connection is opened.
    #
    attr_accessor keep_alive_timeout: Float | Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - started?()
    # -->
    # Returns `true` if the HTTP session has been started:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.started? # => false
    #     http.start
    #     http.started? # => true
    #     http.finish # => nil
    #     http.started? # => false
    #
    #     Net::HTTP.start(hostname) do |http|
    #       http.started?
    #     end # => true
    #     http.started? # => false
    #
    def started?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - active?()
    # -->
    #
    alias active? started?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns whether to close the connection when the response is empty;
    # initially `false`.
    #
    attr_accessor close_on_empty_response: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl?()
    # -->
    # Returns `true` if `self` uses SSL, `false` otherwise. See Net::HTTP#use_ssl=.
    #
    def use_ssl?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl=(flag)
    # -->
    # Sets whether a new session is to use [Transport Layer
    # Security](https://en.wikipedia.org/wiki/Transport_Layer_Security):
    #
    # Raises IOError if attempting to change during a session.
    #
    # Raises OpenSSL::SSL::SSLError if the port is not an HTTPS port.
    #
    def use_ssl=: (boolish flag) -> void

    SSL_IVNAMES: Array[untyped]

    SSL_ATTRIBUTES: Array[Symbol]

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the path to a CA certification file in PEM format.
    #
    attr_accessor ca_file: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the path of to CA directory containing certification files in
    # PEM format.
    #
    attr_accessor ca_path: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the OpenSSL::X509::Certificate object to be used for client
    # certification.
    #
    attr_accessor cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the X509::Store to be used for verifying peer certificate.
    #
    attr_accessor cert_store: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the available SSL ciphers. See
    # [OpenSSL::SSL::SSLContext#ciphers=](rdoc-ref:OpenSSL::SSL::SSLContext#ciphers-
    # 3D).
    #
    attr_accessor ciphers: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the extra X509 certificates to be added to the certificate
    # chain. See
    # [OpenSSL::SSL::SSLContext#add_certificate](rdoc-ref:OpenSSL::SSL::SSLContext#a
    # dd_certificate).
    #
    attr_accessor extra_chain_cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
    #
    attr_accessor key: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the SSL timeout seconds.
    #
    attr_accessor ssl_timeout: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the SSL version. See
    # [OpenSSL::SSL::SSLContext#ssl_version=](rdoc-ref:OpenSSL::SSL::SSLContext#ssl_
    # version-3D).
    #
    attr_accessor ssl_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the minimum SSL version. See
    # [OpenSSL::SSL::SSLContext#min_version=](rdoc-ref:OpenSSL::SSL::SSLContext#min_
    # version-3D).
    #
    attr_accessor min_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the maximum SSL version. See
    # [OpenSSL::SSL::SSLContext#max_version=](rdoc-ref:OpenSSL::SSL::SSLContext#max_
    # version-3D).
    #
    attr_accessor max_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the callback for the server certification verification.
    #
    attr_accessor verify_callback: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the maximum depth for the certificate chain verification.
    #
    attr_accessor verify_depth: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the flags for server the certification verification at the
    # beginning of the SSL/TLS session. OpenSSL::SSL::VERIFY_NONE or
    # OpenSSL::SSL::VERIFY_PEER are acceptable.
    #
    attr_accessor verify_mode: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns whether to verify that the server certificate is valid for the
    # hostname. See
    # [OpenSSL::SSL::SSLContext#verify_hostname=](rdoc-ref:OpenSSL::SSL::SSLContext#
    # attribute-i-verify_mode).
    #
    attr_accessor verify_hostname: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - peer_cert()
    # -->
    # Returns the X509 certificate chain (an array of strings) for the session's
    # socket peer, or `nil` if none.
    #
    def peer_cert: () -> (nil | untyped)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - start() { |http| ... }
    # -->
    # Starts an HTTP session.
    #
    # Without a block, returns `self`:
    #
    #     http = Net::HTTP.new(hostname)
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #     http.start
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=true>
    #     http.started? # => true
    #     http.finish
    #
    # With a block, calls the block with `self`, finishes the session when the block
    # exits, and returns the block's value:
    #
    #     http.start do |http|
    #       http
    #     end
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #     http.started? # => false
    #
    def start: [T] () { (Net::HTTP) -> T } -> T
             | () -> Net::HTTP

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - finish()
    # -->
    # Finishes the HTTP session:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.start
    #     http.started? # => true
    #     http.finish   # => nil
    #     http.started? # => false
    #
    # Raises IOError if not in a session.
    #
    def finish: () -> void

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Proxy(p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil)
    # -->
    # Creates an HTTP proxy class which behaves like Net::HTTP, but performs all
    # access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    #
    def self.Proxy: (?interned p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass) -> untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_class?()
    # -->
    # Returns true if self is a class which was created by HTTP::Proxy.
    #
    def self.proxy_class?: () -> bool

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the address of the proxy host, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the port number of the proxy host, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the user name for accessing the proxy, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the password for accessing the proxy, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy?()
    # -->
    # Returns `true` if a proxy server is defined, `false` otherwise; see [Proxy
    # Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    def proxy?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_from_env?()
    # -->
    # Returns `true` if the proxy server is defined in the environment, `false`
    # otherwise; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    def proxy_from_env?: () -> bool

    def proxy_uri: () -> (nil | URI::Generic)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyaddr()
    # -->
    #
    alias proxyaddr proxy_address

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyport()
    # -->
    #
    alias proxyport proxy_port

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get(path, initheader = nil) {|res| ... }
    # -->
    # Sends a GET request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Get object created from string `path`
    # and initial headers hash `initheader`.
    #
    # With a block given, calls the block with the response body:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.get('/todos/1') do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
    #
    # With no block given, simply returns the response object:
    #
    #     http.get('/') # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Related:
    #
    # *   Net::HTTP::Get: request class for HTTP method GET.
    # *   Net::HTTP.get: sends GET request, returns response body.
    #
    def get: (String path, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head(path, initheader = nil)
    # -->
    # Sends a HEAD request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Head object created from string `path`
    # and initial headers hash `initheader`:
    #
    #     res = http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #     res.body                    # => nil
    #     res.to_hash.take(3)
    #     # =>
    #     [["date", ["Wed, 15 Feb 2023 15:25:42 GMT"]],
    #      ["content-type", ["application/json; charset=utf-8"]],
    #      ["connection", ["close"]]]
    #
    def head: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(path, data, initheader = nil) {|res| ... }
    # -->
    # Sends a POST request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Post object created from string `path`,
    # string `data`, and initial headers hash `initheader`.
    #
    # With a block given, calls the block with the response body:
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.post('/todos', data) do |res|
    #       p res
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # Output:
    #
    #     "{\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\",\n  \"id\": 201\n}"
    #
    # With no block given, simply returns the response object:
    #
    #     http.post('/todos', data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # Related:
    #
    # *   Net::HTTP::Post: request class for HTTP method POST.
    # *   Net::HTTP.post: sends POST request, returns response body.
    #
    def post: (String path, String data, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - patch(path, data, initheader = nil) {|res| ... }
    # -->
    # Sends a PATCH request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Patch object created from string
    # `path`, string `data`, and initial headers hash `initheader`.
    #
    # With a block given, calls the block with the response body:
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.patch('/todos/1', data) do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false,\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\"\n}"
    #
    # With no block given, simply returns the response object:
    #
    #     http.patch('/todos/1', data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def patch: (String path, String data, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - put(path, data, initheader = nil)
    # -->
    # Sends a PUT request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Put object created from string `path`,
    # string `data`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.put('/todos/1', data) # => #<Net::HTTPOK 200 OK readbody=true>
    #
    def put: (String path, String data, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proppatch(path, body, initheader = nil)
    # -->
    # Sends a PROPPATCH request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Proppatch object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.proppatch('/todos/1', data)
    #
    def proppatch: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - lock(path, body, initheader = nil)
    # -->
    # Sends a LOCK request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Lock object created from string `path`,
    # string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.lock('/todos/1', data)
    #
    def lock: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - unlock(path, body, initheader = nil)
    # -->
    # Sends an UNLOCK request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Unlock object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.unlock('/todos/1', data)
    #
    def unlock: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - options(path, initheader = nil)
    # -->
    # Sends an Options request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Options object created from string
    # `path` and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.options('/')
    #
    def options: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - propfind(path, body = nil, initheader = {'Depth' => '0'})
    # -->
    # Sends a PROPFIND request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Propfind object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.propfind('/todos/1', data)
    #
    def propfind: (String path, ?untyped? body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - delete(path, initheader = {'Depth' => 'Infinity'})
    # -->
    # Sends a DELETE request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Delete object created from string
    # `path` and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.delete('/todos/1')
    #
    def delete: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - move(path, initheader = nil)
    # -->
    # Sends a MOVE request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Move object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.move('/todos/1')
    #
    def move: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - copy(path, initheader = nil)
    # -->
    # Sends a COPY request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Copy object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.copy('/todos/1')
    #
    def copy: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - mkcol(path, body = nil, initheader = nil)
    # -->
    # Sends a MKCOL request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Mkcol object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http.mkcol('/todos/1', data)
    #     http = Net::HTTP.new(hostname)
    #
    def mkcol: (String path, ?untyped? body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - trace(path, initheader = nil)
    # -->
    # Sends a TRACE request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Trace object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.trace('/todos/1')
    #
    def trace: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_get(path, initheader = nil) { |response| ... }
    # -->
    # Sends a GET request to the server; forms the response into a Net::HTTPResponse
    # object.
    #
    # The request is based on the Net::HTTP::Get object created from string `path`
    # and initial headers hash `initheader`.
    #
    # With no block given, returns the response object:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.request_get('/todos') # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # With a block given, calls the block with the response object and returns the
    # response object:
    #
    #     http.request_get('/todos') do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     #<Net::HTTPOK 200 OK readbody=false>
    #
    def request_get: (String path, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_head(path, initheader = nil, &block)
    # -->
    # Sends a HEAD request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Head object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #
    def request_head: (String path, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_post(path, data, initheader = nil) { |response| ... }
    # -->
    # Sends a POST request to the server; forms the response into a
    # Net::HTTPResponse object.
    #
    # The request is based on the Net::HTTP::Post object created from string `path`,
    # string `data`, and initial headers hash `initheader`.
    #
    # With no block given, returns the response object:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.post('/todos', 'xyzzy')
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # With a block given, calls the block with the response body and returns the
    # response object:
    #
    #     http.post('/todos', 'xyzzy') do |res|
    #       p res
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # Output:
    #
    #     "{\n  \"xyzzy\": \"\",\n  \"id\": 201\n}"
    #
    def request_post: (String path, String data, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    def request_put: (String path, String data, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get2(path, initheader = nil)
    # -->
    #
    alias get2 request_get

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head2(path, initheader = nil, &block)
    # -->
    #
    alias head2 request_head

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post2(path, data, initheader = nil)
    # -->
    #
    alias post2 request_post

    alias put2 request_put

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - send_request(name, path, data = nil, header = nil)
    # -->
    # Sends an HTTP request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTPRequest object created from string
    # `path`, string `data`, and initial headers hash `header`. That object is an
    # instance of the [subclass of
    # Net::HTTPRequest](rdoc-ref:Net::HTTPRequest@Request+Subclasses), that
    # corresponds to the given uppercase string `name`, which must be an [HTTP
    # request method](https://en.wikipedia.org/wiki/HTTP#Request_methods) or a
    # [WebDAV request method](https://en.wikipedia.org/wiki/WebDAV#Implementation).
    #
    # Examples:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.send_request('GET', '/todos/1')
    #     # => #<Net::HTTPOK 200 OK readbody=true>
    #     http.send_request('POST', '/todos', 'xyzzy')
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def send_request: (String name, String path, ?String? data, ?Hash[String, untyped]? header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request(req, body = nil) { |response| ... }
    # -->
    # Sends the given request `req` to the server; forms the response into a
    # Net::HTTPResponse object.
    #
    # The given `req` must be an instance of a [subclass of
    # Net::HTTPRequest](rdoc-ref:Net::HTTPRequest@Request+Subclasses). Argument
    # `body` should be given only if needed for the request.
    #
    # With no block given, returns the response object:
    #
    #     http = Net::HTTP.new(hostname)
    #
    #     req = Net::HTTP::Get.new('/todos/1')
    #     http.request(req)
    #     # => #<Net::HTTPOK 200 OK readbody=true>
    #
    #     req = Net::HTTP::Post.new('/todos')
    #     http.request(req, 'xyzzy')
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # With a block given, calls the block with the response and returns the
    # response:
    #
    #     req = Net::HTTP::Get.new('/todos/1')
    #     http.request(req) do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     #<Net::HTTPOK 200 OK readbody=false>
    #
    def request: (Net::HTTPRequest req, ?String? body) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse
  end

  # <!-- rdoc-file=lib/net/http/generic_request.rb -->
  # HTTPGenericRequest is the parent of the Net::HTTPRequest class.
  #
  # Do not use this directly; instead, use a subclass of Net::HTTPRequest.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  class HTTPGenericRequest
    include Net::HTTPHeader

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - new(m, reqbody, resbody, uri_or_path, initheader = nil)
    # -->
    #
    def initialize: (String m, boolish reqbody, boolish resbody, URI::Generic | String uri_or_path, ?Hash[String, untyped] initheader) -> Net::HTTP

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the string method name for the request:
    #
    #     Net::HTTP::Get.new(uri).method  # => "GET"
    #     Net::HTTP::Post.new(uri).method # => "POST"
    #
    attr_reader method: String

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the string path for the request:
    #
    #     Net::HTTP::Get.new(uri).path # => "/"
    #     Net::HTTP::Post.new('example.com').path # => "example.com"
    #
    attr_reader path: String

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the URI object for the request, or `nil` if none:
    #
    #     Net::HTTP::Get.new(uri).uri
    #     # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
    #     Net::HTTP::Get.new('example.com').uri # => nil
    #
    attr_reader uri: URI::Generic

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns `false` if the request's header `'Accept-Encoding'` has been set
    # manually or deleted (indicating that the user intends to handle encoding in
    # the response), `true` otherwise:
    #
    #     req = Net::HTTP::Get.new(uri) # => #<Net::HTTP::Get GET>
    #     req['Accept-Encoding']        # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
    #     req.decode_content            # => true
    #     req['Accept-Encoding'] = 'foo'
    #     req.decode_content            # => false
    #     req.delete('Accept-Encoding')
    #     req.decode_content            # => false
    #
    attr_reader decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - inspect()
    # -->
    # Returns a string representation of the request:
    #
    #     Net::HTTP::Post.new(uri).inspect # => "#<Net::HTTP::Post POST>"
    #
    def inspect: () -> String

    def []=: (untyped key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - request_body_permitted?()
    # -->
    # Returns whether the request may have a body:
    #
    #     Net::HTTP::Post.new(uri).request_body_permitted? # => true
    #     Net::HTTP::Get.new(uri).request_body_permitted?  # => false
    #
    def request_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - response_body_permitted?()
    # -->
    # Returns whether the response may have a body:
    #
    #     Net::HTTP::Post.new(uri).response_body_permitted? # => true
    #     Net::HTTP::Head.new(uri).response_body_permitted? # => false
    #
    def response_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_exist?()
    # -->
    #
    def body_exist?: () -> bool

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the string body for the request, or `nil` if there is none:
    #
    #     req = Net::HTTP::Post.new(uri)
    #     req.body # => nil
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.body # => "{\"title\": \"foo\",\"body\": \"bar\",\"userId\": 1}"
    # ----
    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body=(str)
    # -->
    # Sets the body for the request:
    #
    #     req = Net::HTTP::Post.new(uri)
    #     req.body # => nil
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.body # => "{\"title\": \"foo\",\"body\": \"bar\",\"userId\": 1}"
    #
    attr_accessor body: String?

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the body stream object for the request, or `nil` if there is none:
    #
    #     req = Net::HTTP::Post.new(uri)          # => #<Net::HTTP::Post POST>
    #     req.body_stream                         # => nil
    #     require 'stringio'
    #     req.body_stream = StringIO.new('xyzzy') # => #<StringIO:0x0000027d1e5affa8>
    #     req.body_stream                         # => #<StringIO:0x0000027d1e5affa8>
    # ----
    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_stream=(input)
    # -->
    # Sets the body stream for the request:
    #
    #     req = Net::HTTP::Post.new(uri)          # => #<Net::HTTP::Post POST>
    #     req.body_stream                         # => nil
    #     require 'stringio'
    #     req.body_stream = StringIO.new('xyzzy') # => #<StringIO:0x0000027d1e5affa8>
    #     req.body_stream                         # => #<StringIO:0x0000027d1e5affa8>
    #
    attr_accessor body_stream: untyped
  end

  # <!-- rdoc-file=lib/net/http/header.rb -->
  # The HTTPHeader module provides access to HTTP headers.
  #
  # The module is included in:
  #
  # *   Net::HTTPGenericRequest (and therefore Net::HTTPRequest).
  # *   Net::HTTPResponse.
  #
  #
  # The headers are a hash-like collection of key/value pairs called *fields*.
  #
  # ## Request and Response Fields
  #
  # Headers may be included in:
  #
  # *   A Net::HTTPRequest object: the object's headers will be sent with the
  #     request. Any fields may be defined in the request; see
  #     [Setters](rdoc-ref:Net::HTTPHeader@Setters).
  # *   A Net::HTTPResponse object: the objects headers are usually those returned
  #     from the host. Fields may be retrieved from the object; see
  #     [Getters](rdoc-ref:Net::HTTPHeader@Getters) and
  #     [Iterators](rdoc-ref:Net::HTTPHeader@Iterators).
  #
  #
  # Exactly which fields should be sent or expected depends on the host; see:
  #
  # *   [Request
  #     fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_f
  #     ields).
  # *   [Response
  #     fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_
  #     fields).
  #
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Fields
  #
  # A header field is a key/value pair.
  #
  # ### Field Keys
  #
  # A field key may be:
  #
  # *   A string: Key `'Accept'` is treated as if it were `'Accept'.downcase`;
  #     i.e., `'accept'`.
  # *   A symbol: Key `:Accept` is treated as if it were `:Accept.to_s.downcase`;
  #     i.e., `'accept'`.
  #
  #
  # Examples:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req[:accept]  # => "*/*"
  #     req['Accept'] # => "*/*"
  #     req['ACCEPT'] # => "*/*"
  #
  #     req['accept'] = 'text/html'
  #     req[:accept] = 'text/html'
  #     req['ACCEPT'] = 'text/html'
  #
  # ### Field Values
  #
  # A field value may be returned as an array of strings or as a string:
  #
  # *   These methods return field values as arrays:
  #
  #     *   #get_fields: Returns the array value for the given key, or `nil` if it
  #         does not exist.
  #     *   #to_hash: Returns a hash of all header fields: each key is a field
  #         name; its value is the array value for the field.
  #
  #
  # *   These methods return field values as string; the string value for a field
  #     is equivalent to `self[key.downcase.to_s].join(', '))`:
  #
  #     *   #[]: Returns the string value for the given key, or `nil` if it does
  #         not exist.
  #     *   #fetch: Like #[], but accepts a default value to be returned if the
  #         key does not exist.
  #
  #
  #
  # The field value may be set:
  #
  # *   #[]=: Sets the value for the given key; the given value may be a string, a
  #     symbol, an array, or a hash.
  # *   #add_field: Adds a given value to a value for the given key (not
  #     overwriting the existing value).
  # *   #delete: Deletes the field for the given key.
  #
  #
  # Example field values:
  #
  # *   String:
  #
  #         req['Accept'] = 'text/html' # => "text/html"
  #         req['Accept']               # => "text/html"
  #         req.get_fields('Accept')    # => ["text/html"]
  #
  # *   Symbol:
  #
  #         req['Accept'] = :text    # => :text
  #         req['Accept']            # => "text"
  #         req.get_fields('Accept') # => ["text"]
  #
  # *   Simple array:
  #
  #         req[:foo] = %w[bar baz bat]
  #         req[:foo]            # => "bar, baz, bat"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat"]
  #
  # *   Simple hash:
  #
  #         req[:foo] = {bar: 0, baz: 1, bat: 2}
  #         req[:foo]            # => "bar, 0, baz, 1, bat, 2"
  #         req.get_fields(:foo) # => ["bar", "0", "baz", "1", "bat", "2"]
  #
  # *   Nested:
  #
  #         req[:foo] = [%w[bar baz], {bat: 0, bam: 1}]
  #         req[:foo]            # => "bar, baz, bat, 0, bam, 1"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat", "0", "bam", "1"]
  #
  #         req[:foo] = {bar: %w[baz bat], bam: {bah: 0, bad: 1}}
  #         req[:foo]            # => "bar, baz, bat, bam, bah, 0, bad, 1"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat", "bam", "bah", "0", "bad", "1"]
  #
  #
  # ## Convenience Methods
  #
  # Various convenience methods retrieve values, set values, query values, set
  # form values, or iterate over fields.
  #
  # ### Setters
  #
  # Method #[]= can set any field, but does little to validate the new value; some
  # of the other setter methods provide some validation:
  #
  # *   #[]=: Sets the string or array value for the given key.
  # *   #add_field: Creates or adds to the array value for the given key.
  # *   #basic_auth: Sets the string authorization header for `'Authorization'`.
  # *   #content_length=: Sets the integer length for field `'Content-Length`.
  # *   #content_type=: Sets the string value for field `'Content-Type'`.
  # *   #proxy_basic_auth: Sets the string authorization header for
  #     `'Proxy-Authorization'`.
  # *   #set_range: Sets the value for field `'Range'`.
  #
  #
  # ### Form Setters
  #
  # *   #set_form: Sets an HTML form data set.
  # *   #set_form_data: Sets header fields and a body from HTML form data.
  #
  #
  # ### Getters
  #
  # Method #[] can retrieve the value of any field that exists, but always as a
  # string; some of the other getter methods return something different from the
  # simple string value:
  #
  # *   #[]: Returns the string field value for the given key.
  # *   #content_length: Returns the integer value of field `'Content-Length'`.
  # *   #content_range: Returns the Range value of field `'Content-Range'`.
  # *   #content_type: Returns the string value of field `'Content-Type'`.
  # *   #fetch: Returns the string field value for the given key.
  # *   #get_fields: Returns the array field value for the given `key`.
  # *   #main_type: Returns first part of the string value of field
  #     `'Content-Type'`.
  # *   #sub_type: Returns second part of the string value of field
  #     `'Content-Type'`.
  # *   #range: Returns an array of Range objects of field `'Range'`, or `nil`.
  # *   #range_length: Returns the integer length of the range given in field
  #     `'Content-Range'`.
  # *   #type_params: Returns the string parameters for `'Content-Type'`.
  #
  #
  # ### Queries
  #
  # *   #chunked?: Returns whether field `'Transfer-Encoding'` is set to
  #     `'chunked'`.
  # *   #connection_close?: Returns whether field `'Connection'` is set to
  #     `'close'`.
  # *   #connection_keep_alive?: Returns whether field `'Connection'` is set to
  #     `'keep-alive'`.
  # *   #key?: Returns whether a given key exists.
  #
  #
  # ### Iterators
  #
  # *   #each_capitalized: Passes each field capitalized-name/value pair to the
  #     block.
  # *   #each_capitalized_name: Passes each capitalized field name to the block.
  # *   #each_header: Passes each field name/value pair to the block.
  # *   #each_name: Passes each field name to the block.
  # *   #each_value: Passes each string field value to the block.
  #
  module HTTPHeader
    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - initialize_http_header(initheader)
    # -->
    #
    def initialize_http_header: (Hash[untyped, untyped] initheader) -> void

    def size: () -> Integer

    alias length size

    # A previous incarnation of `interned` for backward-compatibility (see #1499)
    %a{steep:deprecated}
    type key = interned

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - [](key)
    # -->
    # Returns the string field value for the case-insensitive field `key`, or `nil`
    # if there is no such key; see [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Connection'] # => "keep-alive"
    #     res['Nosuch']     # => nil
    #
    # Note that some field values may be retrieved via convenience methods; see
    # [Getters](rdoc-ref:Net::HTTPHeader@Getters).
    #
    def []: (interned key) -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - []=(key, val)
    # -->
    # Sets the value for the case-insensitive `key` to `val`, overwriting the
    # previous value if the field exists; see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req['Accept'] # => "*/*"
    #     req['Accept'] = 'text/html'
    #     req['Accept'] # => "text/html"
    #
    # Note that some field values may be set via convenience methods; see
    # [Setters](rdoc-ref:Net::HTTPHeader@Setters).
    #
    def []=: (interned key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - add_field(key, val)
    # -->
    # Adds value `val` to the value array for field `key` if the field exists;
    # creates the field with the given `key` and `val` if it does not exist. see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.add_field('Foo', 'bar')
    #     req['Foo']            # => "bar"
    #     req.add_field('Foo', 'baz')
    #     req['Foo']            # => "bar, baz"
    #     req.add_field('Foo', %w[baz bam])
    #     req['Foo']            # => "bar, baz, baz, bam"
    #     req.get_fields('Foo') # => ["bar", "baz", "baz", "bam"]
    #
    def add_field: (interned key, untyped val) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_field(key, val)
    # -->
    #
    def set_field: (interned key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - append_field_value(ary, val)
    # -->
    #
    def append_field_value: (untyped ary, untyped val) -> void

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - get_fields(key)
    # -->
    # Returns the array field value for the given `key`, or `nil` if there is no
    # such field; see [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.get_fields('Connection') # => ["keep-alive"]
    #     res.get_fields('Nosuch')     # => nil
    #
    def get_fields: (interned key) -> (nil | Array[String])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - fetch(key, default_val = nil) {|key| ... } -> object
    #   - fetch(key, default_val = nil) -> value or default_val
    # -->
    # With a block, returns the string value for `key` if it exists; otherwise
    # returns the value of the block; ignores the `default_val`; see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #
    #     # Field exists; block not called.
    #     res.fetch('Connection') do |value|
    #       fail 'Cannot happen'
    #     end # => "keep-alive"
    #
    #     # Field does not exist; block called.
    #     res.fetch('Nosuch') do |value|
    #       value.downcase
    #     end # => "nosuch"
    #
    # With no block, returns the string value for `key` if it exists; otherwise,
    # returns `default_val` if it was given; otherwise raises an exception:
    #
    #     res.fetch('Connection', 'Foo') # => "keep-alive"
    #     res.fetch('Nosuch', 'Foo')     # => "Foo"
    #     res.fetch('Nosuch')            # Raises KeyError.
    #
    def fetch: (interned key) -> String
             | (interned key, untyped) -> untyped
             | (interned key) { (String) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_header() { |key| ... }
    # -->
    # Calls the block with each key/value pair:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_header do |key, value|
    #       p [key, value] if key.start_with?('c')
    #     end
    #
    # Output:
    #
    #     ["content-type", "application/json; charset=utf-8"]
    #     ["connection", "keep-alive"]
    #     ["cache-control", "max-age=43200"]
    #     ["cf-cache-status", "HIT"]
    #     ["cf-ray", "771d17e9bc542cf5-ORD"]
    #
    # Returns an enumerator if no block is given.
    #
    # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
    #
    def each_header: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                   | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each()
    # -->
    #
    alias each each_header

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_name() { |key| ... }
    # -->
    # Calls the block with each field key:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_key do |key|
    #       p key if key.start_with?('c')
    #     end
    #
    # Output:
    #
    #     "content-type"
    #     "connection"
    #     "cache-control"
    #     "cf-cache-status"
    #     "cf-ray"
    #
    # Returns an enumerator if no block is given.
    #
    # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
    #
    def each_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                 | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_key()
    # -->
    #
    alias each_key each_name

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized_name() { |key| ... }
    # -->
    # Calls the block with each capitalized field name:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_capitalized_name do |key|
    #       p key if key.start_with?('C')
    #     end
    #
    # Output:
    #
    #     "Content-Type"
    #     "Connection"
    #     "Cache-Control"
    #     "Cf-Cache-Status"
    #     "Cf-Ray"
    #
    # The capitalization is system-dependent; see [Case
    # Mapping](rdoc-ref:case_mapping.rdoc).
    #
    # Returns an enumerator if no block is given.
    #
    def each_capitalized_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                             | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_value() { |value| ... }
    # -->
    # Calls the block with each string field value:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_value do |value|
    #       p value if value.start_with?('c')
    #     end
    #
    # Output:
    #
    #     "chunked"
    #     "cf-q-config;dur=6.0000002122251e-06"
    #     "cloudflare"
    #
    # Returns an enumerator if no block is given.
    #
    def each_value: () { (String) -> untyped } -> Hash[String, Array[String]]
                  | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - delete(key)
    # -->
    # Removes the header for the given case-insensitive `key` (see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields)); returns the deleted value, or
    # `nil` if no such field exists:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.delete('Accept') # => ["*/*"]
    #     req.delete('Nosuch') # => nil
    #
    def delete: (interned key) -> (Array[String] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - key?(key)
    # -->
    # Returns `true` if the field for the case-insensitive `key` exists, `false`
    # otherwise:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.key?('Accept') # => true
    #     req.key?('Nosuch') # => false
    #
    def key?: (interned key) -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - to_hash()
    # -->
    # Returns a hash of the key/value pairs:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.to_hash
    #     # =>
    #     {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
    #      "accept"=>["*/*"],
    #      "user-agent"=>["Ruby"],
    #      "host"=>["jsonplaceholder.typicode.com"]}
    #
    def to_hash: () -> Hash[String, Array[String]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized() { |capitalize(k), join(', ')| ... }
    # -->
    # Like #each_header, but the keys are returned in capitalized form.
    #
    # Net::HTTPHeader#canonical_each is an alias for
    # Net::HTTPHeader#each_capitalized.
    #
    def each_capitalized: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                        | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - canonical_each()
    # -->
    #
    alias canonical_each each_capitalized

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - capitalize(name)
    # -->
    #
    def capitalize: (interned name) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range()
    # -->
    # Returns an array of Range objects that represent the value of field `'Range'`,
    # or `nil` if there is no such field; see [Range request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request
    # -header):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req['Range'] = 'bytes=0-99,200-299,400-499'
    #     req.range # => [0..99, 200..299, 400..499]
    #     req.delete('Range')
    #     req.range # # => nil
    #
    def range: () -> (nil | Array[Range[Integer]])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_range(length) -> length
    #   - set_range(offset, length) -> range
    #   - set_range(begin..length) -> range
    # -->
    # Sets the value for field `'Range'`; see [Range request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request
    # -header):
    #
    # With argument `length`:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.set_range(100)      # => 100
    #     req['Range']            # => "bytes=0-99"
    #
    # With arguments `offset` and `length`:
    #
    #     req.set_range(100, 100) # => 100...200
    #     req['Range']            # => "bytes=100-199"
    #
    # With argument `range`:
    #
    #     req.set_range(100..199) # => 100..199
    #     req['Range']            # => "bytes=100-199"
    #
    # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
    #
    def set_range: (Range[Integer] | Numeric r, ?Integer? e) -> Range[Integer]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range=(r, e = nil)
    # -->
    #
    alias range= set_range

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length()
    # -->
    # Returns the value of field `'Content-Length'` as an integer, or `nil` if there
    # is no such field; see [Content-Length request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-lengt
    # h-request-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/nosuch/1')
    #     res.content_length # => 2
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.content_length # => nil
    #
    def content_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length=(len)
    # -->
    # Sets the value of field `'Content-Length'` to the given numeric; see
    # [Content-Length response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-lengt
    # h-response-header):
    #
    #     _uri = uri.dup
    #     hostname = _uri.hostname           # => "jsonplaceholder.typicode.com"
    #     _uri.path = '/posts'               # => "/posts"
    #     req = Net::HTTP::Post.new(_uri)    # => #<Net::HTTP::Post POST>
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.content_length = req.body.size # => 42
    #     req.content_type = 'application/json'
    #     res = Net::HTTP.start(hostname) do |http|
    #       http.request(req)
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def content_length=: (Integer len) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - chunked?()
    # -->
    # Returns `true` if field `'Transfer-Encoding'` exists and has value
    # `'chunked'`, `false` otherwise; see [Transfer-Encoding response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#transfer-enco
    # ding-response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Transfer-Encoding'] # => "chunked"
    #     res.chunked?             # => true
    #
    def chunked?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_range()
    # -->
    # Returns a Range object representing the value of field `'Content-Range'`, or
    # `nil` if no such field exists; see [Content-Range response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range
    # -response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Content-Range'] # => nil
    #     res['Content-Range'] = 'bytes 0-499/1000'
    #     res['Content-Range'] # => "bytes 0-499/1000"
    #     res.content_range    # => 0..499
    #
    def content_range: () -> (Range[Integer] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range_length()
    # -->
    # Returns the integer representing length of the value of field
    # `'Content-Range'`, or `nil` if no such field exists; see [Content-Range
    # response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range
    # -response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Content-Range'] # => nil
    #     res['Content-Range'] = 'bytes 0-499/1000'
    #     res.range_length     # => 500
    #
    def range_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type()
    # -->
    # Returns the [media type](https://en.wikipedia.org/wiki/Media_type) from the
    # value of field `'Content-Type'`, or `nil` if no such field exists; see
    # [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.content_type    # => "application/json"
    #
    def content_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - main_type()
    # -->
    # Returns the leading ('type') part of the [media
    # type](https://en.wikipedia.org/wiki/Media_type) from the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.main_type       # => "application"
    #
    def main_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - sub_type()
    # -->
    # Returns the trailing ('subtype') part of the [media
    # type](https://en.wikipedia.org/wiki/Media_type) from the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.sub_type        # => "json"
    #
    def sub_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - type_params()
    # -->
    # Returns the trailing ('parameters') part of the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.type_params     # => {"charset"=>"utf-8"}
    #
    def type_params: () -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_content_type(type, params = {})
    # -->
    # Sets the value of field `'Content-Type'`; returns the new value; see
    # [Content-Type request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # request-header):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.set_content_type('application/json') # => ["application/json"]
    #
    # Net::HTTPHeader#content_type= is an alias for
    # Net::HTTPHeader#set_content_type.
    #
    def set_content_type: (interned `type`, ?Hash[untyped, untyped] params) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type=(type, params = {})
    # -->
    #
    alias content_type= set_content_type

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form_data(params, sep = '&')
    # -->
    # Sets the request body to a URL-encoded string derived from argument `params`,
    # and sets request header field `'Content-Type'` to
    # `'application/x-www-form-urlencoded'`.
    #
    # The resulting request is suitable for HTTP request `POST` or `PUT`.
    #
    # Argument `params` must be suitable for use as argument `enum` to
    # [URI.encode_www_form](rdoc-ref:URI.encode_www_form).
    #
    # With only argument `params` given, sets the body to a URL-encoded string with
    # the default separator `'&'`:
    #
    #     req = Net::HTTP::Post.new('example.com')
    #
    #     req.set_form_data(q: 'ruby', lang: 'en')
    #     req.body            # => "q=ruby&lang=en"
    #     req['Content-Type'] # => "application/x-www-form-urlencoded"
    #
    #     req.set_form_data([['q', 'ruby'], ['lang', 'en']])
    #     req.body            # => "q=ruby&lang=en"
    #
    #     req.set_form_data(q: ['ruby', 'perl'], lang: 'en')
    #     req.body            # => "q=ruby&q=perl&lang=en"
    #
    #     req.set_form_data([['q', 'ruby'], ['q', 'perl'], ['lang', 'en']])
    #     req.body            # => "q=ruby&q=perl&lang=en"
    #
    # With string argument `sep` also given, uses that string as the separator:
    #
    #     req.set_form_data({q: 'ruby', lang: 'en'}, '|')
    #     req.body # => "q=ruby|lang=en"
    #
    # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
    #
    def set_form_data: (Hash[untyped, untyped] params, ?String sep) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - form_data=(params, sep = '&')
    # -->
    #
    alias form_data= set_form_data

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form(params, enctype='application/x-www-form-urlencoded', formopt={})
    # -->
    # Stores form data to be used in a `POST` or `PUT` request.
    #
    # The form data given in `params` consists of zero or more fields; each field
    # is:
    #
    # *   A scalar value.
    # *   A name/value pair.
    # *   An IO stream opened for reading.
    #
    #
    # Argument `params` should be an
    # [Enumerable](rdoc-ref:Enumerable@Enumerable+in+Ruby+Classes) (method
    # `params.map` will be called), and is often an array or hash.
    #
    # First, we set up a request:
    #
    #     _uri = uri.dup
    #     _uri.path ='/posts'
    #     req = Net::HTTP::Post.new(_uri)
    #
    # **Argument `params` As an Array**
    #
    # When `params` is an array, each of its elements is a subarray that defines a
    # field; the subarray may contain:
    #
    # *   One string:
    #
    #         req.set_form([['foo'], ['bar'], ['baz']])
    #
    # *   Two strings:
    #
    #         req.set_form([%w[foo 0], %w[bar 1], %w[baz 2]])
    #
    # *   When argument `enctype` (see below) is given as `'multipart/form-data'`:
    #
    #     *   A string name and an IO stream opened for reading:
    #
    #             require 'stringio'
    #             req.set_form([['file', StringIO.new('Ruby is cool.')]])
    #
    #     *   A string name, an IO stream opened for reading, and an options hash,
    #         which may contain these entries:
    #
    #         *   `:filename`: The name of the file to use.
    #         *   `:content_type`: The content type of the uploaded file.
    #
    #
    #         Example:
    #
    #             req.set_form([['file', file, {filename: "other-filename.foo"}]]
    #
    #
    #
    # The various forms may be mixed:
    #
    #     req.set_form(['foo', %w[bar 1], ['file', file]])
    #
    # **Argument `params` As a Hash**
    #
    # When `params` is a hash, each of its entries is a name/value pair that defines
    # a field:
    #
    # *   The name is a string.
    # *   The value may be:
    #
    #     *   `nil`.
    #     *   Another string.
    #     *   An IO stream opened for reading (only when argument `enctype` -- see
    #         below -- is given as `'multipart/form-data'`).
    #
    #
    #
    # Examples:
    #
    #     # Nil-valued fields.
    #     req.set_form({'foo' => nil, 'bar' => nil, 'baz' => nil})
    #
    #     # String-valued fields.
    #     req.set_form({'foo' => 0, 'bar' => 1, 'baz' => 2})
    #
    #     # IO-valued field.
    #     require 'stringio'
    #     req.set_form({'file' => StringIO.new('Ruby is cool.')})
    #
    #     # Mixture of fields.
    #     req.set_form({'foo' => nil, 'bar' => 1, 'file' => file})
    #
    # Optional argument `enctype` specifies the value to be given to field
    # `'Content-Type'`, and must be one of:
    #
    # *   `'application/x-www-form-urlencoded'` (the default).
    # *   `'multipart/form-data'`; see [RFC
    #     7578](https://www.rfc-editor.org/rfc/rfc7578).
    #
    #
    # Optional argument `formopt` is a hash of options (applicable only when
    # argument `enctype` is `'multipart/form-data'`) that may include the following
    # entries:
    #
    # *   `:boundary`: The value is the boundary string for the multipart message.
    #     If not given, the boundary is a random string. See
    #     [Boundary](https://www.rfc-editor.org/rfc/rfc7578#section-4.1).
    # *   `:charset`: Value is the character set for the form submission. Field
    #     names and values of non-file fields should be encoded with this charset.
    #
    def set_form: (Hash[untyped, untyped] params, ?String enctype, ?Hash[untyped, untyped] formopt) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_auth(account, password)
    # -->
    # Sets header `'Authorization'` using the given `account` and `password`
    # strings:
    #
    #     req.basic_auth('my_account', 'my_password')
    #     req['Authorization']
    #     # => "Basic bXlfYWNjb3VudDpteV9wYXNzd29yZA=="
    #
    def basic_auth: (String account, String password) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - proxy_basic_auth(account, password)
    # -->
    # Sets header `'Proxy-Authorization'` using the given `account` and `password`
    # strings:
    #
    #     req.proxy_basic_auth('my_account', 'my_password')
    #     req['Proxy-Authorization']
    #     # => "Basic bXlfYWNjb3VudDpteV9wYXNzd29yZA=="
    #
    def proxy_basic_auth: (String account, String password) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_encode(account, password)
    # -->
    #
    def basic_encode: (String account, String password) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_close?()
    # -->
    # Returns whether the HTTP session is to be closed.
    #
    def connection_close?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_keep_alive?()
    # -->
    # Returns whether the HTTP session is to be kept alive.
    #
    def connection_keep_alive?: () -> bool
  end

  # <!-- rdoc-file=lib/net/http/request.rb -->
  # This class is the base class for Net::HTTP request classes. The class should
  # not be used directly; instead you should use its subclasses, listed below.
  #
  # ## Creating a Request
  #
  # An request object may be created with either a URI or a string hostname:
  #
  #     require 'net/http'
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     req = Net::HTTP::Get.new(uri)          # => #<Net::HTTP::Get GET>
  #     req = Net::HTTP::Get.new(uri.hostname) # => #<Net::HTTP::Get GET>
  #
  # And with any of the subclasses:
  #
  #     req = Net::HTTP::Head.new(uri) # => #<Net::HTTP::Head HEAD>
  #     req = Net::HTTP::Post.new(uri) # => #<Net::HTTP::Post POST>
  #     req = Net::HTTP::Put.new(uri)  # => #<Net::HTTP::Put PUT>
  #     # ...
  #
  # The new instance is suitable for use as the argument to Net::HTTP#request.
  #
  # ## Request Headers
  #
  # A new request object has these header fields by default:
  #
  #     req.to_hash
  #     # =>
  #     {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
  #     "accept"=>["*/*"],
  #     "user-agent"=>["Ruby"],
  #     "host"=>["jsonplaceholder.typicode.com"]}
  #
  # See:
  #
  # *   [Request header
  #     Accept-Encoding](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#
  #     Accept-Encoding) and [Compression and
  #     Decompression](rdoc-ref:Net::HTTP@Compression+and+Decompression).
  # *   [Request header
  #     Accept](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#accept-re
  #     quest-header).
  # *   [Request header
  #     User-Agent](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#user-
  #     agent-request-header).
  # *   [Request header
  #     Host](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#host-reques
  #     t-header).
  #
  #
  # You can add headers or override default headers:
  #
  #     #   res = Net::HTTP::Get.new(uri, {'foo' => '0', 'bar' => '1'})
  #
  # This class (and therefore its subclasses) also includes (indirectly) module
  # Net::HTTPHeader, which gives access to its [methods for setting
  # headers](rdoc-ref:Net::HTTPHeader@Setters).
  #
  # ## Request Subclasses
  #
  # Subclasses for HTTP requests:
  #
  # *   Net::HTTP::Get
  # *   Net::HTTP::Head
  # *   Net::HTTP::Post
  # *   Net::HTTP::Put
  # *   Net::HTTP::Delete
  # *   Net::HTTP::Options
  # *   Net::HTTP::Trace
  # *   Net::HTTP::Patch
  #
  #
  # Subclasses for WebDAV requests:
  #
  # *   Net::HTTP::Propfind
  # *   Net::HTTP::Proppatch
  # *   Net::HTTP::Mkcol
  # *   Net::HTTP::Copy
  # *   Net::HTTP::Move
  # *   Net::HTTP::Lock
  # *   Net::HTTP::Unlock
  #
  class HTTPRequest < HTTPGenericRequest
    # <!--
    #   rdoc-file=lib/net/http/request.rb
    #   - new(path, initheader = nil)
    # -->
    # Creates an HTTP request object for `path`.
    #
    # `initheader` are the default headers to use.  Net::HTTP adds Accept-Encoding
    # to enable compression of the response body unless Accept-Encoding or Range are
    # supplied in `initheader`.
    #
    def initialize: (String path, ?Hash[String, untyped] initheader) -> void
                  | (URI::Generic uri, ?Hash[String, untyped] initheader) -> void
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # GET](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#GE
  # T_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Get.new(uri) # => #<Net::HTTP::Get GET>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  #
  # Related:
  #
  # *   Net::HTTP.get: sends `GET` request, returns response body.
  # *   Net::HTTP#get: sends `GET` request, returns response object.
  #
  class HTTP::Get < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # HEAD](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#H
  # EAD_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Head.new(uri) # => #<Net::HTTP::Head HEAD>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: no.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  #
  # Related:
  #
  # *   Net::HTTP#head: sends `HEAD` request, returns response object.
  #
  class HTTP::Head < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # POST](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#P
  # OST_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Post.new(uri) # => #<Net::HTTP::Post POST>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): no.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  #
  # Related:
  #
  # *   Net::HTTP.post: sends `POST` request, returns response object.
  # *   Net::HTTP#post: sends `POST` request, returns response object.
  #
  class HTTP::Post < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # PUT](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#PU
  # T_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Put.new(uri) # => #<Net::HTTP::Put PUT>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  class HTTP::Put < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # DELETE](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol
  # #DELETE_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts/1'
  #     req = Net::HTTP::Delete.new(uri) # => #<Net::HTTP::Delete DELETE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#delete: sends `DELETE` request, returns response object.
  #
  class HTTP::Delete < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # OPTIONS](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protoco
  # l#OPTIONS_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Options.new(uri) # => #<Net::HTTP::Options OPTIONS>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#options: sends `OPTIONS` request, returns response object.
  #
  class HTTP::Options < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # TRACE](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#
  # TRACE_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Trace.new(uri) # => #<Net::HTTP::Trace TRACE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: no.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#trace: sends `TRACE` request, returns response object.
  #
  class HTTP::Trace < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # PATCH](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#
  # PATCH_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Patch.new(uri) # => #<Net::HTTP::Patch PATCH>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): no.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#patch: sends `PATCH` request, returns response object.
  #
  class HTTP::Patch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # PROPFIND](http://www.webdav.org/specs/rfc4918.html#METHOD_PROPFIND):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Propfind.new(uri) # => #<Net::HTTP::Propfind PROPFIND>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#propfind: sends `PROPFIND` request, returns response object.
  #
  class HTTP::Propfind < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # PROPPATCH](http://www.webdav.org/specs/rfc4918.html#METHOD_PROPPATCH):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Proppatch.new(uri) # => #<Net::HTTP::Proppatch PROPPATCH>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#proppatch: sends `PROPPATCH` request, returns response object.
  #
  class HTTP::Proppatch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # MKCOL](http://www.webdav.org/specs/rfc4918.html#METHOD_MKCOL):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Mkcol.new(uri) # => #<Net::HTTP::Mkcol MKCOL>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#mkcol: sends `MKCOL` request, returns response object.
  #
  class HTTP::Mkcol < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # COPY](http://www.webdav.org/specs/rfc4918.html#METHOD_COPY):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Copy.new(uri) # => #<Net::HTTP::Copy COPY>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#copy: sends `COPY` request, returns response object.
  #
  class HTTP::Copy < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # MOVE](http://www.webdav.org/specs/rfc4918.html#METHOD_MOVE):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Move.new(uri) # => #<Net::HTTP::Move MOVE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#move: sends `MOVE` request, returns response object.
  #
  class HTTP::Move < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # LOCK](http://www.webdav.org/specs/rfc4918.html#METHOD_LOCK):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Lock.new(uri) # => #<Net::HTTP::Lock LOCK>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#lock: sends `LOCK` request, returns response object.
  #
  class HTTP::Lock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # UNLOCK](http://www.webdav.org/specs/rfc4918.html#METHOD_UNLOCK):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Unlock.new(uri) # => #<Net::HTTP::Unlock UNLOCK>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#unlock: sends `UNLOCK` request, returns response object.
  #
  class HTTP::Unlock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # This class is the base class for Net::HTTP response classes.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Returned Responses
  #
  # Method Net::HTTP.get_response returns an instance of one of the subclasses of
  # Net::HTTPResponse:
  #
  #     Net::HTTP.get_response(uri)
  #     # => #<Net::HTTPOK 200 OK readbody=true>
  #     Net::HTTP.get_response(hostname, '/nosuch')
  #     # => #<Net::HTTPNotFound 404 Not Found readbody=true>
  #
  # As does method Net::HTTP#request:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Class Net::HTTPResponse includes module Net::HTTPHeader, which provides access
  # to response header values via (among others):
  #
  # *   Hash-like method `[]`.
  # *   Specific reader methods, such as `content_type`.
  #
  #
  # Examples:
  #
  #     res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
  #     res['Content-Type']               # => "text/html; charset=UTF-8"
  #     res.content_type                  # => "text/html"
  #
  # ## Response Subclasses
  #
  # Class Net::HTTPResponse has a subclass for each [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can look
  # up the response class for a given code:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
  #     Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
  #
  # And you can retrieve the status code for a response object:
  #
  #     Net::HTTP.get_response(uri).code                 # => "200"
  #     Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
  #
  # The response subclasses (indentation shows class hierarchy):
  #
  # *   Net::HTTPUnknownResponse (for unhandled HTTP extensions).
  #
  # *   Net::HTTPInformation:
  #
  #     *   Net::HTTPContinue (100)
  #     *   Net::HTTPSwitchProtocol (101)
  #     *   Net::HTTPProcessing (102)
  #     *   Net::HTTPEarlyHints (103)
  #
  #
  # *   Net::HTTPSuccess:
  #
  #     *   Net::HTTPOK (200)
  #     *   Net::HTTPCreated (201)
  #     *   Net::HTTPAccepted (202)
  #     *   Net::HTTPNonAuthoritativeInformation (203)
  #     *   Net::HTTPNoContent (204)
  #     *   Net::HTTPResetContent (205)
  #     *   Net::HTTPPartialContent (206)
  #     *   Net::HTTPMultiStatus (207)
  #     *   Net::HTTPAlreadyReported (208)
  #     *   Net::HTTPIMUsed (226)
  #
  #
  # *   Net::HTTPRedirection:
  #
  #     *   Net::HTTPMultipleChoices (300)
  #     *   Net::HTTPMovedPermanently (301)
  #     *   Net::HTTPFound (302)
  #     *   Net::HTTPSeeOther (303)
  #     *   Net::HTTPNotModified (304)
  #     *   Net::HTTPUseProxy (305)
  #     *   Net::HTTPTemporaryRedirect (307)
  #     *   Net::HTTPPermanentRedirect (308)
  #
  #
  # *   Net::HTTPClientError:
  #
  #     *   Net::HTTPBadRequest (400)
  #     *   Net::HTTPUnauthorized (401)
  #     *   Net::HTTPPaymentRequired (402)
  #     *   Net::HTTPForbidden (403)
  #     *   Net::HTTPNotFound (404)
  #     *   Net::HTTPMethodNotAllowed (405)
  #     *   Net::HTTPNotAcceptable (406)
  #     *   Net::HTTPProxyAuthenticationRequired (407)
  #     *   Net::HTTPRequestTimeOut (408)
  #     *   Net::HTTPConflict (409)
  #     *   Net::HTTPGone (410)
  #     *   Net::HTTPLengthRequired (411)
  #     *   Net::HTTPPreconditionFailed (412)
  #     *   Net::HTTPRequestEntityTooLarge (413)
  #     *   Net::HTTPRequestURITooLong (414)
  #     *   Net::HTTPUnsupportedMediaType (415)
  #     *   Net::HTTPRequestedRangeNotSatisfiable (416)
  #     *   Net::HTTPExpectationFailed (417)
  #     *   Net::HTTPMisdirectedRequest (421)
  #     *   Net::HTTPUnprocessableEntity (422)
  #     *   Net::HTTPLocked (423)
  #     *   Net::HTTPFailedDependency (424)
  #     *   Net::HTTPUpgradeRequired (426)
  #     *   Net::HTTPPreconditionRequired (428)
  #     *   Net::HTTPTooManyRequests (429)
  #     *   Net::HTTPRequestHeaderFieldsTooLarge (431)
  #     *   Net::HTTPUnavailableForLegalReasons (451)
  #
  #
  # *   Net::HTTPServerError:
  #
  #     *   Net::HTTPInternalServerError (500)
  #     *   Net::HTTPNotImplemented (501)
  #     *   Net::HTTPBadGateway (502)
  #     *   Net::HTTPServiceUnavailable (503)
  #     *   Net::HTTPGatewayTimeOut (504)
  #     *   Net::HTTPVersionNotSupported (505)
  #     *   Net::HTTPVariantAlsoNegotiates (506)
  #     *   Net::HTTPInsufficientStorage (507)
  #     *   Net::HTTPLoopDetected (508)
  #     *   Net::HTTPNotExtended (510)
  #     *   Net::HTTPNetworkAuthenticationRequired (511)
  #
  #
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTPResponse
    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body_permitted?()
    # -->
    # true if the response has a body.
    #
    def self.body_permitted?: () -> bool

    public

    include Net::HTTPHeader

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP version supported by the server.
    #
    attr_reader http_version: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result code string. For example, '302'.  You can also determine the
    # response type by examining which response subclass the response object is an
    # instance of.
    #
    attr_reader code: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    attr_reader message: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    alias msg message

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The URI used to fetch this response.  The response URI is only available if a
    # URI was used to create the request.
    #
    attr_reader uri: URI::Generic | nil

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # Set to true automatically when the request did not contain an Accept-Encoding
    # header from the user.
    #
    attr_accessor decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    def code_type: () -> untyped

    def error!: () -> untyped

    def error_type: () -> (Net::HTTPError | Net::HTTPServerException | Net::HTTPRetriableError | Net::HTTPFatalError)

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - value()
    # -->
    # Raises an HTTP error if the response is not 2xx (success).
    #
    def value: () -> (nil | untyped)

    def uri=: (URI::Generic uri) -> void

    interface _Dest
      def <<: (String) -> void
    end

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - read_body(dest = nil, &block)
    # -->
    # Gets the entity body returned by the remote HTTP server.
    #
    # If a block is given, the body is passed to the block, and the body is provided
    # in fragments, as it is read in from the socket.
    #
    # If `dest` argument is given, response is read into that variable, with
    # `dest#<<` method (it could be String or IO, or any other object responding to
    # `<<`).
    #
    # Calling this method a second or subsequent time for the same HTTPResponse
    # object will return the value already read.
    #
    #     http.request_get('/index.html') {|res|
    #       puts res.read_body
    #     }
    #
    #     http.request_get('/index.html') {|res|
    #       p res.read_body.object_id   # 538149362
    #       p res.read_body.object_id   # 538149362
    #     }
    #
    #     # using iterator
    #     http.request_get('/index.html') {|res|
    #       res.read_body do |segment|
    #         print segment
    #       end
    #     }
    #
    def read_body: () -> String
                 | (_Dest dest) -> String
                 | () { (String) -> void } -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body()
    # -->
    # Returns the string response body; note that repeated calls for the unmodified
    # body return a cached string:
    #
    #     path = '/todos/1'
    #     Net::HTTP.start(hostname) do |http|
    #       res = http.get(path)
    #       p res.body
    #       p http.head(path).body # No body.
    #     end
    #
    # Output:
    #
    #     "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
    #     nil
    #
    def body: () -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body=(value)
    # -->
    # Sets the body of the response to the given value.
    #
    def body=: (untyped value) -> void

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - entity()
    # -->
    #
    alias entity body
  end

  class HTTPUnknownResponse < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for informational (1xx) HTTP response classes.
  #
  # An informational response indicates that the request was received and
  # understood.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.1xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#1xx_in
  #     formational_response).
  #
  class HTTPInformation < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for success (2xx) HTTP response classes.
  #
  # A success response indicates the action requested by the client was received,
  # understood, and accepted.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.2xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_su
  #     ccess).
  #
  class HTTPSuccess < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for redirection (3xx) HTTP response classes.
  #
  # A redirection response indicates the client must take additional action to
  # complete the request.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.3xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_re
  #     direction).
  #
  class HTTPRedirection < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPRetriableError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for client error (4xx) HTTP response classes.
  #
  # A client error response indicates that the client may have caused an error.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.4xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_cl
  #     ient_errors).
  #
  class HTTPClientError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: untyped
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for server error (5xx) HTTP response classes.
  #
  # A server error response indicates that the server failed to fulfill a request.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.5xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_se
  #     rver_errors).
  #
  class HTTPServerError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPFatalError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Continue` responses (status code 100).
  #
  # A `Continue` response indicates that the server has received the request
  # headers.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-100-continue).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#100).
  #
  class HTTPContinue < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Switching Protocol` responses (status code 101).
  #
  # The <tt>Switching Protocol<tt> response indicates that the server has received
  # a request to switch protocols, and has agreed to do so.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-101-switching-proto
  #     cols).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#101).
  #
  class HTTPSwitchProtocol < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Processing` responses (status code 102).
  #
  # The `Processing` response indicates that the server has received and is
  # processing the request, but no response is available yet.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 2518](https://www.rfc-editor.org/rfc/rfc2518#section-10.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#102).
  #
  class HTTPProcessing < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Early Hints` responses (status code 103).
  #
  # The `Early Hints` indicates that the server has received and is processing the
  # request, and contains certain headers; the final response is not available
  # yet.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).
  # *   [RFC 8297](https://www.rfc-editor.org/rfc/rfc8297.html#section-2).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#103).
  #
  class HTTPEarlyHints < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `OK` responses (status code 200).
  #
  # The `OK` response indicates that the server has received a request and has
  # responded successfully.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-200-ok).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#200).
  #
  class HTTPOK < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Created` responses (status code 201).
  #
  # The `Created` response indicates that the server has received and has
  # fulfilled a request to create a new resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-201-created).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#201).
  #
  class HTTPCreated < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Accepted` responses (status code 202).
  #
  # The `Accepted` response indicates that the server has received and is
  # processing a request, but the processing has not yet been completed.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-202-accepted).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#202).
  #
  class HTTPAccepted < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Non-Authoritative Information` responses (status code
  # 203).
  #
  # The `Non-Authoritative Information` response indicates that the server is a
  # transforming proxy (such as a Web accelerator) that received a 200 OK response
  # from its origin, and is returning a modified version of the origin's response.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-203-non-authoritati
  #     ve-infor).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#203).
  #
  class HTTPNonAuthoritativeInformation < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `No Content` responses (status code 204).
  #
  # The `No Content` response indicates that the server successfully processed the
  # request, and is not returning any content.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-204-no-content).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#204).
  #
  class HTTPNoContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Reset Content` responses (status code 205).
  #
  # The `Reset Content` response indicates that the server successfully processed
  # the request, asks that the client reset its document view, and is not
  # returning any content.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-205-reset-content).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#205).
  #
  class HTTPResetContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Partial Content` responses (status code 206).
  #
  # The `Partial Content` response indicates that the server is delivering only
  # part of the resource (byte serving) due to a Range header in the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-206-partial-content
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#206).
  #
  class HTTPPartialContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multi-Status (WebDAV)` responses (status code 207).
  #
  # The `Multi-Status (WebDAV)` response indicates that the server has received
  # the request, and that the message body can contain a number of separate
  # response codes.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 4818](https://www.rfc-editor.org/rfc/rfc4918#section-11.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#207).
  #
  class HTTPMultiStatus < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Already Reported (WebDAV)` responses (status code 208).
  #
  # The `Already Reported (WebDAV)` response indicates that the server has
  # received the request, and that the members of a DAV binding have already been
  # enumerated in a preceding part of the (multi-status) response, and are not
  # being included again.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 5842](https://www.rfc-editor.org/rfc/rfc5842.html#section-7.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#208).
  #
  class HTTPAlreadyReported < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `IM Used` responses (status code 226).
  #
  # The `IM Used` response indicates that the server has fulfilled a request for
  # the resource, and the response is a representation of the result of one or
  # more instance-manipulations applied to the current instance.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 3229](https://www.rfc-editor.org/rfc/rfc3229.html#section-10.4.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#226).
  #
  class HTTPIMUsed < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multiple Choices` responses (status code 300).
  #
  # The `Multiple Choices` response indicates that the server offers multiple
  # options for the resource from which the client may choose.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-300-multiple-choice
  #     s).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#300).
  #
  class HTTPMultipleChoices < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multiple Choices` responses (status code 300).
  #
  # The `Multiple Choices` response indicates that the server offers multiple
  # options for the resource from which the client may choose.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-300-multiple-choice
  #     s).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#300).
  #
  HTTPMultipleChoice: HTTPMultipleChoices

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Moved Permanently` responses (status code 301).
  #
  # The `Moved Permanently` response indicates that links or records returning
  # this response should be updated to use the given URL.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-301-moved-permanent
  #     ly).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#301).
  #
  class HTTPMovedPermanently < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Found` responses (status code 302).
  #
  # The `Found` response indicates that the client should look at (browse to)
  # another URL.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-302-found).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#302).
  #
  class HTTPFound < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `See Other` responses (status code 303).
  #
  # The response to the request can be found under another URI using the GET
  # method.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-303-see-other).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#303).
  #
  class HTTPSeeOther < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Modified` responses (status code 304).
  #
  # Indicates that the resource has not been modified since the version specified
  # by the request headers.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-304-not-modified).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#304).
  #
  class HTTPNotModified < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Use Proxy` responses (status code 305).
  #
  # The requested resource is available only through a proxy, whose address is
  # provided in the response.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-305-use-proxy).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#305).
  #
  class HTTPUseProxy < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Temporary Redirect` responses (status code 307).
  #
  # The request should be repeated with another URI; however, future requests
  # should still use the original URI.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-307-temporary-redir
  #     ect).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#307).
  #
  class HTTPTemporaryRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Permanent Redirect` responses (status code 308).
  #
  # This and all future requests should be directed to the given URI.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-308-permanent-redir
  #     ect).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#308).
  #
  class HTTPPermanentRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Bad Request` responses (status code 400).
  #
  # The server cannot or will not process the request due to an apparent client
  # error.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-400-bad-request).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#400).
  #
  class HTTPBadRequest < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unauthorized` responses (status code 401).
  #
  # Authentication is required, but either was not provided or failed.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-401-unauthorized).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#401).
  #
  class HTTPUnauthorized < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Payment Required` responses (status code 402).
  #
  # Reserved for future use.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-402-payment-require
  #     d).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#402).
  #
  class HTTPPaymentRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Forbidden` responses (status code 403).
  #
  # The request contained valid data and was understood by the server, but the
  # server is refusing action.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-403-forbidden).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#403).
  #
  class HTTPForbidden < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Found` responses (status code 404).
  #
  # The requested resource could not be found but may be available in the future.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-404-not-found).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#404).
  #
  class HTTPNotFound < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Method Not Allowed` responses (status code 405).
  #
  # The request method is not supported for the requested resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-405-method-not-allo
  #     wed).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#405).
  #
  class HTTPMethodNotAllowed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Acceptable` responses (status code 406).
  #
  # The requested resource is capable of generating only content that not
  # acceptable according to the Accept headers sent in the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-406-not-acceptable)
  #     .
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#406).
  #
  class HTTPNotAcceptable < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Proxy Authentication Required` responses (status code
  # 407).
  #
  # The client must first authenticate itself with the proxy.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-407-proxy-authentic
  #     ation-re).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#407).
  #
  class HTTPProxyAuthenticationRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Request Timeout` responses (status code 408).
  #
  # The server timed out waiting for the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-408-request-timeout
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#408).
  #
  class HTTPRequestTimeout < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Conflict` responses (status code 409).
  #
  # The request could not be processed because of conflict in the current state of
  # the resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-409-conflict).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#409).
  #
  class HTTPConflict < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Gone` responses (status code 410).
  #
  # The resource requested was previously in use but is no longer available and
  # will not be available again.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-410-gone).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#410).
  #
  class HTTPGone < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Length Required` responses (status code 411).
  #
  # The request did not specify the length of its content, which is required by
  # the requested resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-411-length-required
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#411).
  #
  class HTTPLengthRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Precondition Failed` responses (status code 412).
  #
  # The server does not meet one of the preconditions specified in the request
  # headers.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-412-precondition-fa
  #     iled).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#412).
  #
  class HTTPPreconditionFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Payload Too Large` responses (status code 413).
  #
  # The request is larger than the server is willing or able to process.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-413-content-too-lar
  #     ge).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#413).
  #
  class HTTPPayloadTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `URI Too Long` responses (status code 414).
  #
  # The URI provided was too long for the server to process.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-414-uri-too-long).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#414).
  #
  class HTTPURITooLong < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unsupported Media Type` responses (status code 415).
  #
  # The request entity has a media type which the server or resource does not
  # support.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-415-unsupported-med
  #     ia-type).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#415).
  #
  class HTTPUnsupportedMediaType < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Range Not Satisfiable` responses (status code 416).
  #
  # The request entity has a media type which the server or resource does not
  # support.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-416-range-not-satis
  #     fiable).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#416).
  #
  class HTTPRangeNotSatisfiable < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Expectation Failed` responses (status code 417).
  #
  # The server cannot meet the requirements of the Expect request-header field.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-417-expectation-fai
  #     led).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#417).
  #
  class HTTPExpectationFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Misdirected Request` responses (status code 421).
  #
  # The request was directed at a server that is not able to produce a response.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-421-misdirected-req
  #     uest).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#421).
  #
  class HTTPMisdirectedRequest < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unprocessable Entity` responses (status code 422).
  #
  # The request was well-formed but had semantic errors.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-422-unprocessable-c
  #     ontent).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#422).
  #
  class HTTPUnprocessableEntity < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Locked (WebDAV)` responses (status code 423).
  #
  # The requested resource is locked.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 4918](https://www.rfc-editor.org/rfc/rfc4918#section-11.3).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#423).
  #
  class HTTPLocked < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Failed Dependency (WebDAV)` responses (status code 424).
  #
  # The request failed because it depended on another request and that request
  # failed. See [424 Failed Dependency
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#424).
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 4918](https://www.rfc-editor.org/rfc/rfc4918#section-11.4).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#424).
  #
  class HTTPFailedDependency < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Upgrade Required` responses (status code 426).
  #
  # The client should switch to the protocol given in the Upgrade header field.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-426-upgrade-require
  #     d).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#426).
  #
  class HTTPUpgradeRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Precondition Required` responses (status code 428).
  #
  # The origin server requires the request to be conditional.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-3).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#428).
  #
  class HTTPPreconditionRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Too Many Requests` responses (status code 429).
  #
  # The user has sent too many requests in a given amount of time.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-4).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429).
  #
  class HTTPTooManyRequests < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Request Header Fields Too Large` responses (status code
  # 431).
  #
  # An individual header field is too large, or all the header fields
  # collectively, are too large.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-5).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#431).
  #
  class HTTPRequestHeaderFieldsTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unavailable For Legal Reasons` responses (status code
  # 451).
  #
  # A server operator has received a legal demand to deny access to a resource or
  # to a set of resources that includes the requested resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451).
  # *   [RFC 7725](https://www.rfc-editor.org/rfc/rfc7725.html#section-3).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#451).
  #
  class HTTPUnavailableForLegalReasons < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Internal Server Error` responses (status code 500).
  #
  # An unexpected condition was encountered and no more specific message is
  # suitable.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-500-internal-server
  #     -error).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#500).
  #
  class HTTPInternalServerError < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Implemented` responses (status code 501).
  #
  # The server either does not recognize the request method, or it lacks the
  # ability to fulfil the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-501-not-implemented
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#501).
  #
  class HTTPNotImplemented < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Bad Gateway` responses (status code 502).
  #
  # The server was acting as a gateway or proxy and received an invalid response
  # from the upstream server.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-502-bad-gateway).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#502).
  #
  class HTTPBadGateway < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Service Unavailable` responses (status code 503).
  #
  # The server cannot handle the request (because it is overloaded or down for
  # maintenance).
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-503-service-unavail
  #     able).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#503).
  #
  class HTTPServiceUnavailable < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Gateway Timeout` responses (status code 504).
  #
  # The server was acting as a gateway or proxy and did not receive a timely
  # response from the upstream server.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-504-gateway-timeout
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#504).
  #
  class HTTPGatewayTimeout < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `HTTP Version Not Supported` responses (status code 505).
  #
  # The server does not support the HTTP version used in the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-505-http-version-no
  #     t-suppor).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#505).
  #
  class HTTPVersionNotSupported < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Variant Also Negotiates` responses (status code 506).
  #
  # Transparent content negotiation for the request results in a circular
  # reference.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506).
  # *   [RFC 2295](https://www.rfc-editor.org/rfc/rfc2295#section-8.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#506).
  #
  class HTTPVariantAlsoNegotiates < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Insufficient Storage (WebDAV)` responses (status code
  # 507).
  #
  # The server is unable to store the representation needed to complete the
  # request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507).
  # *   [RFC 4918](https://www.rfc-editor.org/rfc/rfc4918#section-11.5).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#507).
  #
  class HTTPInsufficientStorage < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Loop Detected (WebDAV)` responses (status code 508).
  #
  # The server detected an infinite loop while processing the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508).
  # *   [RFC 5942](https://www.rfc-editor.org/rfc/rfc5842.html#section-7.2).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#508).
  #
  class HTTPLoopDetected < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Extended` responses (status code 510).
  #
  # Further extensions to the request are required for the server to fulfill it.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510).
  # *   [RFC 2774](https://www.rfc-editor.org/rfc/rfc2774.html#section-7).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#510).
  #
  class HTTPNotExtended < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Network Authentication Required` responses (status code
  # 511).
  #
  # The client needs to authenticate to gain network access.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-6).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#511).
  #
  class HTTPNetworkAuthenticationRequired < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # This class is the base class for Net::HTTP response classes.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Returned Responses
  #
  # Method Net::HTTP.get_response returns an instance of one of the subclasses of
  # Net::HTTPResponse:
  #
  #     Net::HTTP.get_response(uri)
  #     # => #<Net::HTTPOK 200 OK readbody=true>
  #     Net::HTTP.get_response(hostname, '/nosuch')
  #     # => #<Net::HTTPNotFound 404 Not Found readbody=true>
  #
  # As does method Net::HTTP#request:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Class Net::HTTPResponse includes module Net::HTTPHeader, which provides access
  # to response header values via (among others):
  #
  # *   Hash-like method `[]`.
  # *   Specific reader methods, such as `content_type`.
  #
  #
  # Examples:
  #
  #     res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
  #     res['Content-Type']               # => "text/html; charset=UTF-8"
  #     res.content_type                  # => "text/html"
  #
  # ## Response Subclasses
  #
  # Class Net::HTTPResponse has a subclass for each [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can look
  # up the response class for a given code:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
  #     Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
  #
  # And you can retrieve the status code for a response object:
  #
  #     Net::HTTP.get_response(uri).code                 # => "200"
  #     Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
  #
  # The response subclasses (indentation shows class hierarchy):
  #
  # *   Net::HTTPUnknownResponse (for unhandled HTTP extensions).
  #
  # *   Net::HTTPInformation:
  #
  #     *   Net::HTTPContinue (100)
  #     *   Net::HTTPSwitchProtocol (101)
  #     *   Net::HTTPProcessing (102)
  #     *   Net::HTTPEarlyHints (103)
  #
  #
  # *   Net::HTTPSuccess:
  #
  #     *   Net::HTTPOK (200)
  #     *   Net::HTTPCreated (201)
  #     *   Net::HTTPAccepted (202)
  #     *   Net::HTTPNonAuthoritativeInformation (203)
  #     *   Net::HTTPNoContent (204)
  #     *   Net::HTTPResetContent (205)
  #     *   Net::HTTPPartialContent (206)
  #     *   Net::HTTPMultiStatus (207)
  #     *   Net::HTTPAlreadyReported (208)
  #     *   Net::HTTPIMUsed (226)
  #
  #
  # *   Net::HTTPRedirection:
  #
  #     *   Net::HTTPMultipleChoices (300)
  #     *   Net::HTTPMovedPermanently (301)
  #     *   Net::HTTPFound (302)
  #     *   Net::HTTPSeeOther (303)
  #     *   Net::HTTPNotModified (304)
  #     *   Net::HTTPUseProxy (305)
  #     *   Net::HTTPTemporaryRedirect (307)
  #     *   Net::HTTPPermanentRedirect (308)
  #
  #
  # *   Net::HTTPClientError:
  #
  #     *   Net::HTTPBadRequest (400)
  #     *   Net::HTTPUnauthorized (401)
  #     *   Net::HTTPPaymentRequired (402)
  #     *   Net::HTTPForbidden (403)
  #     *   Net::HTTPNotFound (404)
  #     *   Net::HTTPMethodNotAllowed (405)
  #     *   Net::HTTPNotAcceptable (406)
  #     *   Net::HTTPProxyAuthenticationRequired (407)
  #     *   Net::HTTPRequestTimeOut (408)
  #     *   Net::HTTPConflict (409)
  #     *   Net::HTTPGone (410)
  #     *   Net::HTTPLengthRequired (411)
  #     *   Net::HTTPPreconditionFailed (412)
  #     *   Net::HTTPRequestEntityTooLarge (413)
  #     *   Net::HTTPRequestURITooLong (414)
  #     *   Net::HTTPUnsupportedMediaType (415)
  #     *   Net::HTTPRequestedRangeNotSatisfiable (416)
  #     *   Net::HTTPExpectationFailed (417)
  #     *   Net::HTTPMisdirectedRequest (421)
  #     *   Net::HTTPUnprocessableEntity (422)
  #     *   Net::HTTPLocked (423)
  #     *   Net::HTTPFailedDependency (424)
  #     *   Net::HTTPUpgradeRequired (426)
  #     *   Net::HTTPPreconditionRequired (428)
  #     *   Net::HTTPTooManyRequests (429)
  #     *   Net::HTTPRequestHeaderFieldsTooLarge (431)
  #     *   Net::HTTPUnavailableForLegalReasons (451)
  #
  #
  # *   Net::HTTPServerError:
  #
  #     *   Net::HTTPInternalServerError (500)
  #     *   Net::HTTPNotImplemented (501)
  #     *   Net::HTTPBadGateway (502)
  #     *   Net::HTTPServiceUnavailable (503)
  #     *   Net::HTTPGatewayTimeOut (504)
  #     *   Net::HTTPVersionNotSupported (505)
  #     *   Net::HTTPVariantAlsoNegotiates (506)
  #     *   Net::HTTPInsufficientStorage (507)
  #     *   Net::HTTPLoopDetected (508)
  #     *   Net::HTTPNotExtended (510)
  #     *   Net::HTTPNetworkAuthenticationRequired (511)
  #
  #
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTPResponse
    CODE_CLASS_TO_OBJ: Hash[untyped, untyped]

    CODE_TO_OBJ: Hash[untyped, untyped]
  end

  HTTP::STATUS_CODES: Hash[Integer, String]

  # <!-- rdoc-file=lib/net/http/exceptions.rb -->
  # Net::HTTP exception class. You cannot use Net::HTTPExceptions directly;
  # instead, you must use its subclasses.
  #
  module HTTPExceptions
    def initialize: (untyped msg, untyped res) -> untyped

    attr_reader response: untyped

    alias data response
  end

  class HTTPError < ProtocolError
    include Net::HTTPExceptions
  end

  class HTTPRetriableError < ProtoRetriableError
    include Net::HTTPExceptions
  end

  class HTTPServerException < ProtoServerError
    # We cannot use the name "HTTPServerError", it is the name of the response.
    include Net::HTTPExceptions
  end

  class HTTPFatalError < ProtoFatalError
    include Net::HTTPExceptions
  end
end
