# A pretty-printer for Ruby objects.
#
# ## What PP Does
#
# Standard output by #p returns this:
#     #<PP:0x81fedf0 @genspace=#<Proc:0x81feda0>, @group_queue=#<PrettyPrint::GroupQueue:0x81fed3c @queue=[[#<PrettyPrint::Group:0x81fed78 @breakables=[], @depth=0, @break=false>], []]>, @buffer=[], @newline="\n", @group_stack=[#<PrettyPrint::Group:0x81fed78 @breakables=[], @depth=0, @break=false>], @buffer_width=0, @indent=0, @maxwidth=79, @output_width=2, @output=#<IO:0x8114ee4>>
#
# Pretty-printed output returns this:
#     #<PP:0x81fedf0
#      @buffer=[],
#      @buffer_width=0,
#      @genspace=#<Proc:0x81feda0>,
#      @group_queue=
#       #<PrettyPrint::GroupQueue:0x81fed3c
#        @queue=
#         [[#<PrettyPrint::Group:0x81fed78 @break=false, @breakables=[], @depth=0>],
#          []]>,
#      @group_stack=
#       [#<PrettyPrint::Group:0x81fed78 @break=false, @breakables=[], @depth=0>],
#      @indent=0,
#      @maxwidth=79,
#      @newline="\n",
#      @output=#<IO:0x8114ee4>,
#      @output_width=2>
#
# ## Usage
#
#     pp(obj)             #=> obj
#     pp obj              #=> obj
#     pp(obj1, obj2, ...) #=> [obj1, obj2, ...]
#     pp()                #=> nil
#
# Output `obj(s)` to `$>` in pretty printed format.
#
# It returns `obj(s)`.
#
# ## Output Customization
#
# To define a customized pretty printing function for your classes, redefine
# method `#pretty_print(pp)` in the class.
#
# `#pretty_print` takes the `pp` argument, which is an instance of the PP class.
# The method uses #text, #breakable, #nest, #group and #pp to print the object.
#
# ## Pretty-Print JSON
#
# To pretty-print JSON refer to JSON#pretty_generate.
#
# ## Author
# Tanaka Akira <akr@fsij.org>
class PP < PrettyPrint
  include PP::PPMethods

  def self.mcall: (untyped obj, untyped mod, untyped meth, *untyped args) { (*untyped) -> untyped } -> untyped

  # Outputs `obj` to `out` in pretty printed format of `width` columns in width.
  #
  # If `out` is omitted, `$>` is assumed. If `width` is omitted, 79 is assumed.
  #
  # PP.pp returns `out`.
  #
  # # arglists 游눩游놓游뚿 << Delete this section
  #     pp(obj, out=$>, width=79)
  #
  def self.pp: (untyped obj, ?untyped `out`, ?untyped width) -> untyped

  # Returns the sharing detection flag as a boolean value. It is false (nil) by
  # default.
  #
  # # arglists 游눩游놓游뚿 << Delete this section
  #     sharing_detection()
  #
  def self.sharing_detection: () -> untyped

  # Sets the sharing detection flag to b.
  #
  # # arglists 游눩游놓游뚿 << Delete this section
  #     sharing_detection=(b)
  #
  def self.sharing_detection=: (untyped b) -> untyped

  # Outputs `obj` to `out` like PP.pp but with no indent and newline.
  #
  # PP.singleline_pp returns `out`.
  #
  # # arglists 游눩游놓游뚿 << Delete this section
  #     singleline_pp(obj, out=$>)
  #
  def self.singleline_pp: (untyped obj, ?untyped `out`) -> untyped

  module PPMethods
    public

    # Check whether the object_id `id` is in the current buffer of objects to be
    # pretty printed. Used to break cycles in chains of objects to be pretty
    # printed.
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     check_inspect_key(id)
    #
    def check_inspect_key: (untyped id) -> untyped

    # A convenience method which is same as follows:
    #
    #     text ','
    #     breakable
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     comma_breakable()
    #
    def comma_breakable: () -> untyped

    # Yields to a block and preserves the previous set of objects being printed.
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     guard_inspect_key() { || ... }
    #
    def guard_inspect_key: () -> untyped

    # A convenience method, like object_group, but also reformats the Object's
    # object_id.
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     object_address_group(obj, &block)
    #
    def object_address_group: (untyped obj) { (*untyped) -> untyped } -> untyped

    # A convenience method which is same as follows:
    #
    #     group(1, '#<' + obj.class.name, '>') { ... }
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     object_group(obj) { || ... }
    #
    def object_group: (untyped obj) { (*untyped) -> untyped } -> untyped

    # Removes an object from the set of objects being pretty printed.
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     pop_inspect_key(id)
    #
    def pop_inspect_key: (untyped id) -> untyped

    # Adds `obj` to the pretty printing buffer using Object#pretty_print or
    # Object#pretty_print_cycle.
    #
    # Object#pretty_print_cycle is used when `obj` is already printed, a.k.a the
    # object reference chain has a cycle.
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     pp(obj)
    #
    def pp: (untyped obj) -> untyped

    # A pretty print for a Hash
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     pp_hash(obj)
    #
    def pp_hash: (untyped obj) -> untyped

    # A present standard failsafe for pretty printing any given Object
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     pp_object(obj)
    #
    def pp_object: (untyped obj) -> untyped

    # Adds the object_id `id` to the set of objects being pretty printed, so as to
    # not repeat objects.
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     push_inspect_key(id)
    #
    def push_inspect_key: (untyped id) -> untyped

    # Adds a separated list. The list is separated by comma with breakable space, by
    # default.
    #
    # #seplist iterates the `list` using `iter_method`. It yields each object to the
    # block given for #seplist. The procedure `separator_proc` is called between
    # each yields.
    #
    # If the iteration is zero times, `separator_proc` is not called at all.
    #
    # If `separator_proc` is nil or not given, +lambda { comma_breakable }+ is used.
    # If `iter_method` is not given, :each is used.
    #
    # For example, following 3 code fragments has similar effect.
    #
    #     q.seplist([1,2,3]) {|v| xxx v }
    #
    #     q.seplist([1,2,3], lambda { q.comma_breakable }, :each) {|v| xxx v }
    #
    #     xxx 1
    #     q.comma_breakable
    #     xxx 2
    #     q.comma_breakable
    #     xxx 3
    #
    # # arglists 游눩游놓游뚿 << Delete this section
    #     seplist(list, sep=nil, iter_method=:each) { |element| ... }
    #
    def seplist: (untyped list, ?untyped sep, ?untyped iter_method) -> untyped
  end

  class SingleLine < PrettyPrint::SingleLine
    include PP::PPMethods
  end

  module ObjectMixin
    public

    def pretty_print: (untyped q) -> untyped

    def pretty_print_cycle: (untyped q) -> untyped

    def pretty_print_inspect: () -> untyped

    def pretty_print_instance_variables: () -> untyped
  end
end

class Array
  # :nodoc:
  def pretty_print: (untyped q) -> untyped

  def pretty_print_cycle: (untyped q) -> untyped
end

class Hash
  # :nodoc:
  def pretty_print: (untyped q) -> untyped

  def pretty_print_cycle: (untyped q) -> untyped
end

class <<
  ENV
  def pretty_print: (untyped q) -> untyped
end

class Struct
  def pretty_print: (untyped q) -> untyped

  def pretty_print_cycle: (untyped q) -> untyped
end

class Range
  # :nodoc:
  def pretty_print: (untyped q) -> untyped
end

class String
  # :nodoc:
  def pretty_print: (untyped q) -> untyped
end

class File < IO
  class Stat
    def pretty_print: (untyped q) -> untyped
  end
end

class MatchData
  # :nodoc:
  def pretty_print: (untyped q) -> untyped
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children: (untyped q, ?untyped names) -> untyped

  def pretty_print: (untyped q) -> untyped
end

class Object < BasicObject
  # :nodoc:
  include PP::ObjectMixin
end

class Numeric
  def pretty_print_cycle: (untyped q) -> untyped

  def pretty_print: (untyped q) -> untyped
end

class Symbol
  def pretty_print_cycle: (untyped q) -> untyped
end

class FalseClass
  def pretty_print_cycle: (untyped q) -> untyped

  def pretty_print: (untyped q) -> untyped
end

class TrueClass
  def pretty_print_cycle: (untyped q) -> untyped

  def pretty_print: (untyped q) -> untyped
end

class NilClass
  def pretty_print_cycle: (untyped q) -> untyped
end

class Module
  def pretty_print: (untyped q) -> untyped
end

module Kernel
  # Returns a pretty printed object as a string.
  #
  # In order to use this method you must first require the PP module:
  #
  #   require 'pp'
  #
  # See the PP module for more information.
  def pretty_inspect: () -> untyped

  # prints arguments in pretty form.
  #
  # pp returns argument(s).
  def pp: (Array[untyped]) -> untyped
end
